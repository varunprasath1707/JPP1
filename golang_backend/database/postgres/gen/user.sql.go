// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: user.sql

package gen

import (
	"context"
	"time"

	database "ZenitusJPP/database"
	"github.com/jackc/pgtype"
)

const addIP = `-- name: AddIP :exec
INSERT INTO unique_visitor
(
    vistor_ip
) VALUES (
    $1
)
`

func (q *Queries) AddIP(ctx context.Context, vistorIp string) error {
	_, err := q.db.Exec(ctx, addIP, vistorIp)
	return err
}

const checkIP = `-- name: CheckIP :one
SELECT count(*) AS cnt
FROM unique_visitor
WHERE vistor_ip = $1
`

func (q *Queries) CheckIP(ctx context.Context, vistorIp string) (int64, error) {
	row := q.db.QueryRow(ctx, checkIP, vistorIp)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const deleteOlderData = `-- name: DeleteOlderData :exec
DELETE FROM user_sms
WHERE
    processed_time + INTERVAL '60 min' < now()
`

func (q *Queries) DeleteOlderData(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOlderData)
	return err
}

const insertDonationTransaction = `-- name: InsertDonationTransaction :one
INSERT INTO user_donation_transaction
(
    user_id,
    transaction_url,
    transaction_token,
    user_name,
    user_email,
    user_amount
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING udt_id
`

type InsertDonationTransactionParams struct {
	UserID           int64          `json:"userId"`
	TransactionUrl   string         `json:"transactionUrl"`
	TransactionToken string         `json:"transactionToken"`
	UserName         string         `json:"userName"`
	UserEmail        string         `json:"userEmail"`
	UserAmount       pgtype.Numeric `json:"userAmount"`
}

func (q *Queries) InsertDonationTransaction(ctx context.Context, arg InsertDonationTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertDonationTransaction,
		arg.UserID,
		arg.TransactionUrl,
		arg.TransactionToken,
		arg.UserName,
		arg.UserEmail,
		arg.UserAmount,
	)
	var udt_id int64
	err := row.Scan(&udt_id)
	return udt_id, err
}

const insertSMS = `-- name: InsertSMS :one
INSERT INTO sms_status
(
    email,
    body,
    email_subject
) VALUES (
    $1,
    $2,
    $3
) RETURNING sms_id
`

type InsertSMSParams struct {
	Email        string `json:"email"`
	Body         string `json:"body"`
	EmailSubject string `json:"emailSubject"`
}

func (q *Queries) InsertSMS(ctx context.Context, arg InsertSMSParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertSMS, arg.Email, arg.Body, arg.EmailSubject)
	var sms_id int64
	err := row.Scan(&sms_id)
	return sms_id, err
}

const insertSMSProcess = `-- name: InsertSMSProcess :exec
INSERT INTO dynamic_data
(
    keys,
    values
)
VALUES (
    'sms_process',
    now() + INTERVAL '1 hour'
)
`

func (q *Queries) InsertSMSProcess(ctx context.Context) error {
	_, err := q.db.Exec(ctx, insertSMSProcess)
	return err
}

const insertTransaction = `-- name: InsertTransaction :one
INSERT INTO user_payment_transaction
(
    user_id,
    transaction_url,
    transaction_token
) VALUES (
    $1,
    $2,
    $3
) RETURNING upt_id
`

type InsertTransactionParams struct {
	UserID           int64  `json:"userId"`
	TransactionUrl   string `json:"transactionUrl"`
	TransactionToken string `json:"transactionToken"`
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertTransaction, arg.UserID, arg.TransactionUrl, arg.TransactionToken)
	var upt_id int64
	err := row.Scan(&upt_id)
	return upt_id, err
}

const insertUserInfo = `-- name: InsertUserInfo :one
INSERT INTO users (
    first_name,
    last_name,
    handle_name,
    display_name,
    email_id,
    gender,
    dob,
    user_address,
    ph_fixed,
    ph_mobile,
    jpp_password,
    is_admin,
    mobile_verification
)
VALUES (
    pgp_sym_encrypt($1, 'SLMSZ1929S')::BYTEA,
    pgp_sym_encrypt($2, 'SLMSZ1929S')::BYTEA,
    pgp_sym_encrypt($3, 'SLMSZ1929S')::BYTEA,
    $4,
    $5,
    $6,
    $7,
    pgp_sym_encrypt($8, 'SLMSZ1929S')::BYTEA,
    pgp_sym_encrypt($9, 'SLMSZ1929S')::BYTEA,
    pgp_sym_encrypt($10, 'SLMSZ1929S')::BYTEA,
    $11,
    $12,
    $13
)
RETURNING user_id
`

type InsertUserInfoParams struct {
	PgpSymEncrypt      string       `json:"pgpSymEncrypt"`
	PgpSymEncrypt_2    string       `json:"pgpSymEncrypt2"`
	PgpSymEncrypt_3    string       `json:"pgpSymEncrypt3"`
	DisplayName        string       `json:"displayName"`
	EmailID            string       `json:"emailId"`
	Gender             SelectGender `json:"gender"`
	Dob                time.Time    `json:"dob"`
	PgpSymEncrypt_4    string       `json:"pgpSymEncrypt4"`
	PgpSymEncrypt_5    string       `json:"pgpSymEncrypt5"`
	PgpSymEncrypt_6    string       `json:"pgpSymEncrypt6"`
	JppPassword        string       `json:"jppPassword"`
	IsAdmin            bool         `json:"isAdmin"`
	MobileVerification bool         `json:"mobileVerification"`
}

func (q *Queries) InsertUserInfo(ctx context.Context, arg InsertUserInfoParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertUserInfo,
		arg.PgpSymEncrypt,
		arg.PgpSymEncrypt_2,
		arg.PgpSymEncrypt_3,
		arg.DisplayName,
		arg.EmailID,
		arg.Gender,
		arg.Dob,
		arg.PgpSymEncrypt_4,
		arg.PgpSymEncrypt_5,
		arg.PgpSymEncrypt_6,
		arg.JppPassword,
		arg.IsAdmin,
		arg.MobileVerification,
	)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const insertUserSMS = `-- name: InsertUserSMS :exec
INSERT INTO user_sms
(
    cnt,
    user_id
)
VALUES (
    $1,
    $2
) RETURNING us_id
`

type InsertUserSMSParams struct {
	Cnt    int32  `json:"cnt"`
	UserID string `json:"userId"`
}

func (q *Queries) InsertUserSMS(ctx context.Context, arg InsertUserSMSParams) error {
	_, err := q.db.Exec(ctx, insertUserSMS, arg.Cnt, arg.UserID)
	return err
}

const memberShipUser = `-- name: MemberShipUser :many
SELECT
    user_id,
    last_name,
    handle_name,
    display_name,
    email_id,
    token,
    gender,
    dob,
    user_address,
    ph_fixed,
    ph_mobile,
    jpp_password,
    otp,
    is_admin,
    mobile_verification,
    is_deleted,
    created_on,
    last_updated_on,
    email_verification,
    otp_email,
    payment_token,
    is_paid,
    paid_date,
    login_datetime
FROM
    users
WHERE
    is_paid = TRUE
    AND paid_date + INTERVAL '+358 Days' < now()
`

type MemberShipUserRow struct {
	UserID             int64             `json:"userId"`
	LastName           []byte            `json:"lastName"`
	HandleName         []byte            `json:"handleName"`
	DisplayName        string            `json:"displayName"`
	EmailID            string            `json:"emailId"`
	Token              string            `json:"token"`
	Gender             SelectGender      `json:"gender"`
	Dob                time.Time         `json:"dob"`
	UserAddress        []byte            `json:"userAddress"`
	PhFixed            []byte            `json:"phFixed"`
	PhMobile           []byte            `json:"phMobile"`
	JppPassword        string            `json:"jppPassword"`
	Otp                int32             `json:"otp"`
	IsAdmin            bool              `json:"isAdmin"`
	MobileVerification bool              `json:"mobileVerification"`
	IsDeleted          bool              `json:"isDeleted"`
	CreatedOn          time.Time         `json:"createdOn"`
	LastUpdatedOn      time.Time         `json:"lastUpdatedOn"`
	EmailVerification  bool              `json:"emailVerification"`
	OtpEmail           int32             `json:"otpEmail"`
	PaymentToken       string            `json:"paymentToken"`
	IsPaid             bool              `json:"isPaid"`
	PaidDate           database.NullTime `json:"paidDate"`
	LoginDatetime      database.NullTime `json:"loginDatetime"`
}

func (q *Queries) MemberShipUser(ctx context.Context) ([]*MemberShipUserRow, error) {
	rows, err := q.db.Query(ctx, memberShipUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MemberShipUserRow{}
	for rows.Next() {
		var i MemberShipUserRow
		if err := rows.Scan(
			&i.UserID,
			&i.LastName,
			&i.HandleName,
			&i.DisplayName,
			&i.EmailID,
			&i.Token,
			&i.Gender,
			&i.Dob,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.JppPassword,
			&i.Otp,
			&i.IsAdmin,
			&i.MobileVerification,
			&i.IsDeleted,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.EmailVerification,
			&i.OtpEmail,
			&i.PaymentToken,
			&i.IsPaid,
			&i.PaidDate,
			&i.LoginDatetime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sMSDelete = `-- name: SMSDelete :exec
DELETE FROM sms_status
WHERE
    status = TRUE
`

func (q *Queries) SMSDelete(ctx context.Context) error {
	_, err := q.db.Exec(ctx, sMSDelete)
	return err
}

const selectAdminContent = `-- name: SelectAdminContent :many
WITH regular_member AS (
    SELECT
        1 AS rid,
        count(*) AS rcnt
    FROM users
    WHERE
        mobile_verification = TRUE
), associate_member AS ( --noqa: L022
    SELECT
        1 AS aid,
        count(*) AS acnt
    FROM users
), visitor_member AS ( --noqa: L022
    SELECT
        1 AS fid,
        count(*) AS fcnt
    FROM unique_visitor
), agenda_count AS ( --noqa: L022
    SELECT
        1 AS agenda_id,
        count(*) AS agenda_count
    FROM agenda_master
), petition_count AS ( --noqa: L022
    SELECT
        1 AS petition_id,
        count(*) AS petition_count
    FROM petition_master
), admin_member AS ( --noqa: L022
    SELECT
        1 AS adid,
        count(*) AS adcnt
    FROM users
    WHERE
        is_admin = TRUE
), female_member AS ( --noqa: L022
    SELECT
        1 AS femaleid,
        count(*) AS femalecount
    FROM users
    WHERE
        gender = 'female'
), male_member AS ( --noqa: L022
    SELECT
        1 AS maleid,
        count(*) AS malecount
    FROM users
    WHERE
        gender = 'male'
), token_count AS ( --noqa: L022
    SELECT
        1 AS tokenid,
        count(DISTINCT token) AS tokencount
    FROM users
) SELECT --noqa: L022
    regular_member.rcnt AS regularcount,
    associate_member.acnt AS associatecount,
    visitor_member.fcnt AS membercount,
    agenda_count.agenda_count,
    petition_count.petition_count,
    admin_member.adcnt AS admincount,
    female_member.femalecount AS femalecount,
    male_member.malecount AS malecount,
    token_count.tokencount AS tokencount
FROM
    regular_member
INNER JOIN associate_member ON regular_member.rid = associate_member.aid
INNER JOIN admin_member ON regular_member.rid = admin_member.adid
INNER JOIN visitor_member ON regular_member.rid = visitor_member.fid
INNER JOIN agenda_count ON regular_member.rid = agenda_count.agenda_id
INNER JOIN petition_count ON regular_member.rid = petition_count.petition_id
INNER JOIN female_member ON regular_member.rid = female_member.femaleid
INNER JOIN male_member ON regular_member.rid = male_member.maleid
INNER JOIN token_count ON regular_member.rid = token_count.tokenid
`

type SelectAdminContentRow struct {
	Regularcount   int64 `json:"regularcount"`
	Associatecount int64 `json:"associatecount"`
	Membercount    int64 `json:"membercount"`
	AgendaCount    int64 `json:"agendaCount"`
	PetitionCount  int64 `json:"petitionCount"`
	Admincount     int64 `json:"admincount"`
	Femalecount    int64 `json:"femalecount"`
	Malecount      int64 `json:"malecount"`
	Tokencount     int64 `json:"tokencount"`
}

func (q *Queries) SelectAdminContent(ctx context.Context) ([]*SelectAdminContentRow, error) {
	rows, err := q.db.Query(ctx, selectAdminContent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAdminContentRow{}
	for rows.Next() {
		var i SelectAdminContentRow
		if err := rows.Scan(
			&i.Regularcount,
			&i.Associatecount,
			&i.Membercount,
			&i.AgendaCount,
			&i.PetitionCount,
			&i.Admincount,
			&i.Femalecount,
			&i.Malecount,
			&i.Tokencount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectDonationTransactionByEmailID = `-- name: SelectDonationTransactionByEmailID :many
SELECT
    udt_id,
    user_id,
    transaction_url,
    transaction_status,
    transaction_token,
    date_time,
    user_name,
    user_email,
    user_amount
FROM
    user_donation_transaction
WHERE
    user_email = $1
ORDER BY date_time DESC
`

func (q *Queries) SelectDonationTransactionByEmailID(ctx context.Context, userEmail string) ([]*UserDonationTransaction, error) {
	rows, err := q.db.Query(ctx, selectDonationTransactionByEmailID, userEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserDonationTransaction{}
	for rows.Next() {
		var i UserDonationTransaction
		if err := rows.Scan(
			&i.UdtID,
			&i.UserID,
			&i.TransactionUrl,
			&i.TransactionStatus,
			&i.TransactionToken,
			&i.DateTime,
			&i.UserName,
			&i.UserEmail,
			&i.UserAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectDonationTransactionByUserID = `-- name: SelectDonationTransactionByUserID :many
SELECT
    udt_id,
    user_id,
    transaction_url,
    transaction_status,
    transaction_token,
    date_time,
    user_name,
    user_email,
    user_amount
FROM
    user_donation_transaction
WHERE
    user_id = $1
ORDER BY date_time DESC
`

func (q *Queries) SelectDonationTransactionByUserID(ctx context.Context, userID int64) ([]*UserDonationTransaction, error) {
	rows, err := q.db.Query(ctx, selectDonationTransactionByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserDonationTransaction{}
	for rows.Next() {
		var i UserDonationTransaction
		if err := rows.Scan(
			&i.UdtID,
			&i.UserID,
			&i.TransactionUrl,
			&i.TransactionStatus,
			&i.TransactionToken,
			&i.DateTime,
			&i.UserName,
			&i.UserEmail,
			&i.UserAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectDynamicData = `-- name: SelectDynamicData :many
SELECT
    dynamic_data.dynamic_data_id,
    dynamic_data.keys,
    dynamic_data.values
FROM
    dynamic_data
ORDER BY dynamic_data.dynamic_data_id
`

func (q *Queries) SelectDynamicData(ctx context.Context) ([]*DynamicDatum, error) {
	rows, err := q.db.Query(ctx, selectDynamicData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DynamicDatum{}
	for rows.Next() {
		var i DynamicDatum
		if err := rows.Scan(&i.DynamicDataID, &i.Keys, &i.Values); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectDynamicDataByKey = `-- name: SelectDynamicDataByKey :many
SELECT
    dynamic_data.dynamic_data_id,
    dynamic_data.keys,
    dynamic_data.values
FROM
    dynamic_data
WHERE
    dynamic_data.keys = $1
`

func (q *Queries) SelectDynamicDataByKey(ctx context.Context, keys string) ([]*DynamicDatum, error) {
	rows, err := q.db.Query(ctx, selectDynamicDataByKey, keys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DynamicDatum{}
	for rows.Next() {
		var i DynamicDatum
		if err := rows.Scan(&i.DynamicDataID, &i.Keys, &i.Values); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectExecutedTime = `-- name: SelectExecutedTime :one
SELECT
    coalesce(max(keys), '-') AS keys,
    coalesce(max(values), '-') AS valueskeys,
    count(*) AS cnt
FROM
    dynamic_data
WHERE
    keys = 'sms_process'
`

type SelectExecutedTimeRow struct {
	Keys       interface{} `json:"keys"`
	Valueskeys interface{} `json:"valueskeys"`
	Cnt        int64       `json:"cnt"`
}

func (q *Queries) SelectExecutedTime(ctx context.Context) (*SelectExecutedTimeRow, error) {
	row := q.db.QueryRow(ctx, selectExecutedTime)
	var i SelectExecutedTimeRow
	err := row.Scan(&i.Keys, &i.Valueskeys, &i.Cnt)
	return &i, err
}

const selectNotice = `-- name: SelectNotice :many
SELECT
    srno,
    notice_text,
    created_on,
    last_updated_on
FROM
    notice_master
`

func (q *Queries) SelectNotice(ctx context.Context) ([]*NoticeMaster, error) {
	rows, err := q.db.Query(ctx, selectNotice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NoticeMaster{}
	for rows.Next() {
		var i NoticeMaster
		if err := rows.Scan(
			&i.Srno,
			&i.NoticeText,
			&i.CreatedOn,
			&i.LastUpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotificationUser = `-- name: SelectNotificationUser :one
SELECT setnotificationforall($1, $2)
`

type SelectNotificationUserParams struct {
	Notificationtext string `json:"notificationtext"`
	Notificationtype string `json:"notificationtype"`
}

func (q *Queries) SelectNotificationUser(ctx context.Context, arg SelectNotificationUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, selectNotificationUser, arg.Notificationtext, arg.Notificationtype)
	var setnotificationforall int64
	err := row.Scan(&setnotificationforall)
	return setnotificationforall, err
}

const selectSMSData = `-- name: SelectSMSData :many
SELECT
    sms_id,
    email,
    body,
    email_subject,
    status
FROM sms_status
WHERE
    status = FALSE
ORDER BY sms_id
`

func (q *Queries) SelectSMSData(ctx context.Context) ([]*SmsStatus, error) {
	rows, err := q.db.Query(ctx, selectSMSData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SmsStatus{}
	for rows.Next() {
		var i SmsStatus
		if err := rows.Scan(
			&i.SmsID,
			&i.Email,
			&i.Body,
			&i.EmailSubject,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTDonationTransactionByUserID = `-- name: SelectTDonationTransactionByUserID :many
SELECT udt_id, user_id, transaction_url, transaction_status, transaction_token, date_time, user_name, user_email, user_amount
FROM
    user_donation_transaction
WHERE
    transaction_token = $1
ORDER BY date_time DESC
`

func (q *Queries) SelectTDonationTransactionByUserID(ctx context.Context, transactionToken string) ([]*UserDonationTransaction, error) {
	rows, err := q.db.Query(ctx, selectTDonationTransactionByUserID, transactionToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserDonationTransaction{}
	for rows.Next() {
		var i UserDonationTransaction
		if err := rows.Scan(
			&i.UdtID,
			&i.UserID,
			&i.TransactionUrl,
			&i.TransactionStatus,
			&i.TransactionToken,
			&i.DateTime,
			&i.UserName,
			&i.UserEmail,
			&i.UserAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTransactionByUserID = `-- name: SelectTransactionByUserID :many
SELECT upt_id, user_id, date_time, transaction_url, transaction_status, transaction_token
FROM user_payment_transaction
WHERE
    user_id = $1
ORDER BY date_time DESC
`

func (q *Queries) SelectTransactionByUserID(ctx context.Context, userID int64) ([]*UserPaymentTransaction, error) {
	rows, err := q.db.Query(ctx, selectTransactionByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserPaymentTransaction{}
	for rows.Next() {
		var i UserPaymentTransaction
		if err := rows.Scan(
			&i.UptID,
			&i.UserID,
			&i.DateTime,
			&i.TransactionUrl,
			&i.TransactionStatus,
			&i.TransactionToken,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserCountByEmail = `-- name: SelectUserCountByEmail :one
SELECT count(*)
FROM users
WHERE
    email_id = $1
`

func (q *Queries) SelectUserCountByEmail(ctx context.Context, emailID string) (int64, error) {
	row := q.db.QueryRow(ctx, selectUserCountByEmail, emailID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const selectUserCountByID = `-- name: SelectUserCountByID :one
SELECT count(*)
FROM users
WHERE
    user_id = $1
`

func (q *Queries) SelectUserCountByID(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, selectUserCountByID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const selectUserCountByMobileNo = `-- name: SelectUserCountByMobileNo :one
SELECT count(*)
FROM users
WHERE
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) = cast($1 AS VARCHAR)
`

func (q *Queries) SelectUserCountByMobileNo(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, selectUserCountByMobileNo, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const selectUserCountByMobileNoEmail = `-- name: SelectUserCountByMobileNoEmail :one
SELECT count(*)
FROM users
WHERE
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) = cast($2 AS VARCHAR)
    AND users.email_id = $1
`

type SelectUserCountByMobileNoEmailParams struct {
	EmailID string `json:"emailId"`
	Column2 string `json:"column2"`
}

func (q *Queries) SelectUserCountByMobileNoEmail(ctx context.Context, arg SelectUserCountByMobileNoEmailParams) (int64, error) {
	row := q.db.QueryRow(ctx, selectUserCountByMobileNoEmail, arg.EmailID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const selectUserCountByUsername = `-- name: SelectUserCountByUsername :one
SELECT count(*)
FROM users
WHERE
    cast(pgp_sym_decrypt(handle_name, 'SLMSZ1929S') AS VARCHAR) = cast($1 AS VARCHAR)
`

func (q *Queries) SelectUserCountByUsername(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, selectUserCountByUsername, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const selectUserIDByEmailPassword = `-- name: SelectUserIDByEmailPassword :one
SELECT
    user_id,
    display_name,
    email_id,
    gender,
    dob,
    token,
    mobile_verification,
    is_admin,
    is_paid,
    email_verification,
    cast(pgp_sym_decrypt(first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name
FROM users
WHERE
    email_id = $1
    AND jpp_password = $2
LIMIT 1
`

type SelectUserIDByEmailPasswordParams struct {
	EmailID     string `json:"emailId"`
	JppPassword string `json:"jppPassword"`
}

type SelectUserIDByEmailPasswordRow struct {
	UserID             int64        `json:"userId"`
	DisplayName        string       `json:"displayName"`
	EmailID            string       `json:"emailId"`
	Gender             SelectGender `json:"gender"`
	Dob                time.Time    `json:"dob"`
	Token              string       `json:"token"`
	MobileVerification bool         `json:"mobileVerification"`
	IsAdmin            bool         `json:"isAdmin"`
	IsPaid             bool         `json:"isPaid"`
	EmailVerification  bool         `json:"emailVerification"`
	FirstName          string       `json:"firstName"`
	LastName           string       `json:"lastName"`
	UserAddress        string       `json:"userAddress"`
	PhFixed            string       `json:"phFixed"`
	PhMobile           string       `json:"phMobile"`
	HandleName         string       `json:"handleName"`
}

func (q *Queries) SelectUserIDByEmailPassword(ctx context.Context, arg SelectUserIDByEmailPasswordParams) (*SelectUserIDByEmailPasswordRow, error) {
	row := q.db.QueryRow(ctx, selectUserIDByEmailPassword, arg.EmailID, arg.JppPassword)
	var i SelectUserIDByEmailPasswordRow
	err := row.Scan(
		&i.UserID,
		&i.DisplayName,
		&i.EmailID,
		&i.Gender,
		&i.Dob,
		&i.Token,
		&i.MobileVerification,
		&i.IsAdmin,
		&i.IsPaid,
		&i.EmailVerification,
		&i.FirstName,
		&i.LastName,
		&i.UserAddress,
		&i.PhFixed,
		&i.PhMobile,
		&i.HandleName,
	)
	return &i, err
}

const selectUserIDByToken = `-- name: SelectUserIDByToken :one
SELECT
    user_id,
    display_name,
    email_id,
    gender,
    dob,
    token,
    mobile_verification,
    is_admin,
    cast(pgp_sym_decrypt(first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name
FROM users
WHERE
    token = $1
LIMIT 1
`

type SelectUserIDByTokenRow struct {
	UserID             int64        `json:"userId"`
	DisplayName        string       `json:"displayName"`
	EmailID            string       `json:"emailId"`
	Gender             SelectGender `json:"gender"`
	Dob                time.Time    `json:"dob"`
	Token              string       `json:"token"`
	MobileVerification bool         `json:"mobileVerification"`
	IsAdmin            bool         `json:"isAdmin"`
	FirstName          string       `json:"firstName"`
	LastName           string       `json:"lastName"`
	UserAddress        string       `json:"userAddress"`
	PhFixed            string       `json:"phFixed"`
	PhMobile           string       `json:"phMobile"`
	HandleName         string       `json:"handleName"`
}

func (q *Queries) SelectUserIDByToken(ctx context.Context, token string) (*SelectUserIDByTokenRow, error) {
	row := q.db.QueryRow(ctx, selectUserIDByToken, token)
	var i SelectUserIDByTokenRow
	err := row.Scan(
		&i.UserID,
		&i.DisplayName,
		&i.EmailID,
		&i.Gender,
		&i.Dob,
		&i.Token,
		&i.MobileVerification,
		&i.IsAdmin,
		&i.FirstName,
		&i.LastName,
		&i.UserAddress,
		&i.PhFixed,
		&i.PhMobile,
		&i.HandleName,
	)
	return &i, err
}

const selectUserInfo = `-- name: SelectUserInfo :many
SELECT
    users.user_id,
    users.email_id,
    users.gender,
    cast(pgp_sym_decrypt(users.first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(users.handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name
FROM
    users
WHERE
    users.is_deleted = FALSE
`

type SelectUserInfoRow struct {
	UserID     int64        `json:"userId"`
	EmailID    string       `json:"emailId"`
	Gender     SelectGender `json:"gender"`
	FirstName  string       `json:"firstName"`
	HandleName string       `json:"handleName"`
}

func (q *Queries) SelectUserInfo(ctx context.Context) ([]*SelectUserInfoRow, error) {
	rows, err := q.db.Query(ctx, selectUserInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectUserInfoRow{}
	for rows.Next() {
		var i SelectUserInfoRow
		if err := rows.Scan(
			&i.UserID,
			&i.EmailID,
			&i.Gender,
			&i.FirstName,
			&i.HandleName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserInfoByEmail = `-- name: SelectUserInfoByEmail :one
SELECT
    user_id,
    cast(pgp_sym_decrypt(handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name,
    email_id,
    jpp_password,
    token,
    otp,
    otp_email,
    payment_token
FROM users
WHERE
    email_id = $1
`

type SelectUserInfoByEmailRow struct {
	UserID       int64  `json:"userId"`
	HandleName   string `json:"handleName"`
	EmailID      string `json:"emailId"`
	JppPassword  string `json:"jppPassword"`
	Token        string `json:"token"`
	Otp          int32  `json:"otp"`
	OtpEmail     int32  `json:"otpEmail"`
	PaymentToken string `json:"paymentToken"`
}

func (q *Queries) SelectUserInfoByEmail(ctx context.Context, emailID string) (*SelectUserInfoByEmailRow, error) {
	row := q.db.QueryRow(ctx, selectUserInfoByEmail, emailID)
	var i SelectUserInfoByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.HandleName,
		&i.EmailID,
		&i.JppPassword,
		&i.Token,
		&i.Otp,
		&i.OtpEmail,
		&i.PaymentToken,
	)
	return &i, err
}

const selectUserInfoByMobile = `-- name: SelectUserInfoByMobile :one
SELECT
    user_id,
    handle_name,
    email_id,
    jpp_password,
    token,
    otp,
    otp_email
FROM users
WHERE
    ph_mobile = $1
`

type SelectUserInfoByMobileRow struct {
	UserID      int64  `json:"userId"`
	HandleName  []byte `json:"handleName"`
	EmailID     string `json:"emailId"`
	JppPassword string `json:"jppPassword"`
	Token       string `json:"token"`
	Otp         int32  `json:"otp"`
	OtpEmail    int32  `json:"otpEmail"`
}

func (q *Queries) SelectUserInfoByMobile(ctx context.Context, phMobile []byte) (*SelectUserInfoByMobileRow, error) {
	row := q.db.QueryRow(ctx, selectUserInfoByMobile, phMobile)
	var i SelectUserInfoByMobileRow
	err := row.Scan(
		&i.UserID,
		&i.HandleName,
		&i.EmailID,
		&i.JppPassword,
		&i.Token,
		&i.Otp,
		&i.OtpEmail,
	)
	return &i, err
}

const selectUserInfoByMobileEmailIDInfo = `-- name: SelectUserInfoByMobileEmailIDInfo :one
SELECT
    user_id,
    handle_name,
    email_id,
    jpp_password,
    token,
    otp,
    otp_email
FROM users
WHERE
    cast(pgp_sym_decrypt(ph_mobile, 'SLMSZ1929S') AS VARCHAR) = cast($2 AS VARCHAR)
    AND email_id = $1
`

type SelectUserInfoByMobileEmailIDInfoParams struct {
	EmailID string `json:"emailId"`
	Column2 string `json:"column2"`
}

type SelectUserInfoByMobileEmailIDInfoRow struct {
	UserID      int64  `json:"userId"`
	HandleName  []byte `json:"handleName"`
	EmailID     string `json:"emailId"`
	JppPassword string `json:"jppPassword"`
	Token       string `json:"token"`
	Otp         int32  `json:"otp"`
	OtpEmail    int32  `json:"otpEmail"`
}

func (q *Queries) SelectUserInfoByMobileEmailIDInfo(ctx context.Context, arg SelectUserInfoByMobileEmailIDInfoParams) (*SelectUserInfoByMobileEmailIDInfoRow, error) {
	row := q.db.QueryRow(ctx, selectUserInfoByMobileEmailIDInfo, arg.EmailID, arg.Column2)
	var i SelectUserInfoByMobileEmailIDInfoRow
	err := row.Scan(
		&i.UserID,
		&i.HandleName,
		&i.EmailID,
		&i.JppPassword,
		&i.Token,
		&i.Otp,
		&i.OtpEmail,
	)
	return &i, err
}

const selectUserInfoByUserId = `-- name: SelectUserInfoByUserId :one
SELECT
    display_name,
    email_id,
    gender,
    dob,
    mobile_verification,
    email_verification,
    is_paid,
    cast(pgp_sym_decrypt(first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name,
    coalesce((paid_date + INTERVAL '365DAY')::TIMESTAMP, '0001-01-01') AS membership_completion_date
FROM users
WHERE
    user_id = $1
`

type SelectUserInfoByUserIdRow struct {
	DisplayName              string       `json:"displayName"`
	EmailID                  string       `json:"emailId"`
	Gender                   SelectGender `json:"gender"`
	Dob                      time.Time    `json:"dob"`
	MobileVerification       bool         `json:"mobileVerification"`
	EmailVerification        bool         `json:"emailVerification"`
	IsPaid                   bool         `json:"isPaid"`
	FirstName                string       `json:"firstName"`
	LastName                 string       `json:"lastName"`
	UserAddress              string       `json:"userAddress"`
	PhFixed                  string       `json:"phFixed"`
	PhMobile                 string       `json:"phMobile"`
	HandleName               string       `json:"handleName"`
	MembershipCompletionDate interface{}  `json:"membershipCompletionDate"`
}

func (q *Queries) SelectUserInfoByUserId(ctx context.Context, userID int64) (*SelectUserInfoByUserIdRow, error) {
	row := q.db.QueryRow(ctx, selectUserInfoByUserId, userID)
	var i SelectUserInfoByUserIdRow
	err := row.Scan(
		&i.DisplayName,
		&i.EmailID,
		&i.Gender,
		&i.Dob,
		&i.MobileVerification,
		&i.EmailVerification,
		&i.IsPaid,
		&i.FirstName,
		&i.LastName,
		&i.UserAddress,
		&i.PhFixed,
		&i.PhMobile,
		&i.HandleName,
		&i.MembershipCompletionDate,
	)
	return &i, err
}

const selectUserSMSCount = `-- name: SelectUserSMSCount :one
SELECT count(*) AS cnt
FROM
    user_sms
WHERE
    user_id = $1
`

func (q *Queries) SelectUserSMSCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, selectUserSMSCount, userID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const updateDeletedByUserId = `-- name: UpdateDeletedByUserId :exec
UPDATE users
SET
    is_deleted = TRUE
WHERE
    user_id = $1
`

func (q *Queries) UpdateDeletedByUserId(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, updateDeletedByUserId, userID)
	return err
}

const updateDonationTransactionById = `-- name: UpdateDonationTransactionById :exec
UPDATE user_donation_transaction
SET
    transaction_status = $3
WHERE
    user_id = $1
    AND transaction_token = $2
`

type UpdateDonationTransactionByIdParams struct {
	UserID            int64  `json:"userId"`
	TransactionToken  string `json:"transactionToken"`
	TransactionStatus bool   `json:"transactionStatus"`
}

func (q *Queries) UpdateDonationTransactionById(ctx context.Context, arg UpdateDonationTransactionByIdParams) error {
	_, err := q.db.Exec(ctx, updateDonationTransactionById, arg.UserID, arg.TransactionToken, arg.TransactionStatus)
	return err
}

const updateDonationTransactionByToken = `-- name: UpdateDonationTransactionByToken :exec
UPDATE user_donation_transaction
SET
    transaction_status = $2
WHERE
    transaction_token = $1
`

type UpdateDonationTransactionByTokenParams struct {
	TransactionToken  string `json:"transactionToken"`
	TransactionStatus bool   `json:"transactionStatus"`
}

func (q *Queries) UpdateDonationTransactionByToken(ctx context.Context, arg UpdateDonationTransactionByTokenParams) error {
	_, err := q.db.Exec(ctx, updateDonationTransactionByToken, arg.TransactionToken, arg.TransactionStatus)
	return err
}

const updateLoginStatus = `-- name: UpdateLoginStatus :exec
UPDATE users
SET
    token = ''
WHERE
    login_datetime IS NOT NULL
    AND login_datetime + INTERVAL '+24 Hours' < now()
`

func (q *Queries) UpdateLoginStatus(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateLoginStatus)
	return err
}

const updateNotice = `-- name: UpdateNotice :exec
UPDATE notice_master
SET
    notice_text = $2
WHERE
    srno = $1
`

type UpdateNoticeParams struct {
	Srno       int64  `json:"srno"`
	NoticeText string `json:"noticeText"`
}

func (q *Queries) UpdateNotice(ctx context.Context, arg UpdateNoticeParams) error {
	_, err := q.db.Exec(ctx, updateNotice, arg.Srno, arg.NoticeText)
	return err
}

const updateOTPByEmailIDID = `-- name: UpdateOTPByEmailIDID :exec
UPDATE users
SET
    otp = $2,
    otp_email = $3
WHERE
    email_id = $1
`

type UpdateOTPByEmailIDIDParams struct {
	EmailID  string `json:"emailId"`
	Otp      int32  `json:"otp"`
	OtpEmail int32  `json:"otpEmail"`
}

func (q *Queries) UpdateOTPByEmailIDID(ctx context.Context, arg UpdateOTPByEmailIDIDParams) error {
	_, err := q.db.Exec(ctx, updateOTPByEmailIDID, arg.EmailID, arg.Otp, arg.OtpEmail)
	return err
}

const updatePaymentTokenByEmailIDID = `-- name: UpdatePaymentTokenByEmailIDID :exec
UPDATE users
SET
    payment_token = $2,
    is_paid = $3,
    paid_date = $4
WHERE
    email_id = $1
`

type UpdatePaymentTokenByEmailIDIDParams struct {
	EmailID      string            `json:"emailId"`
	PaymentToken string            `json:"paymentToken"`
	IsPaid       bool              `json:"isPaid"`
	PaidDate     database.NullTime `json:"paidDate"`
}

func (q *Queries) UpdatePaymentTokenByEmailIDID(ctx context.Context, arg UpdatePaymentTokenByEmailIDIDParams) error {
	_, err := q.db.Exec(ctx, updatePaymentTokenByEmailIDID,
		arg.EmailID,
		arg.PaymentToken,
		arg.IsPaid,
		arg.PaidDate,
	)
	return err
}

const updateProcessTime = `-- name: UpdateProcessTime :exec
UPDATE
dynamic_data
SET
    values = now() + INTERVAL '1 hour'
WHERE
    keys = 'sms_process'
`

func (q *Queries) UpdateProcessTime(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateProcessTime)
	return err
}

const updateSMS = `-- name: UpdateSMS :exec
UPDATE sms_status
SET
    status = TRUE
WHERE
    sms_id = $1
`

func (q *Queries) UpdateSMS(ctx context.Context, smsID int64) error {
	_, err := q.db.Exec(ctx, updateSMS, smsID)
	return err
}

const updateTokenByID = `-- name: UpdateTokenByID :exec
UPDATE users
SET
    token = $1,
    login_datetime = now()
WHERE
    user_id = $2
`

type UpdateTokenByIDParams struct {
	Token  string `json:"token"`
	UserID int64  `json:"userId"`
}

func (q *Queries) UpdateTokenByID(ctx context.Context, arg UpdateTokenByIDParams) error {
	_, err := q.db.Exec(ctx, updateTokenByID, arg.Token, arg.UserID)
	return err
}

const updateTransactionById = `-- name: UpdateTransactionById :exec
UPDATE user_payment_transaction
SET
    transaction_status = $3
WHERE
    user_id = $1
    AND transaction_token = $2
`

type UpdateTransactionByIdParams struct {
	UserID            int64  `json:"userId"`
	TransactionToken  string `json:"transactionToken"`
	TransactionStatus bool   `json:"transactionStatus"`
}

func (q *Queries) UpdateTransactionById(ctx context.Context, arg UpdateTransactionByIdParams) error {
	_, err := q.db.Exec(ctx, updateTransactionById, arg.UserID, arg.TransactionToken, arg.TransactionStatus)
	return err
}

const updateUserInfoByID = `-- name: UpdateUserInfoByID :exec
UPDATE users
SET
    first_name = pgp_sym_encrypt($2, 'SLMSZ1929S')::BYTEA,
    last_name = pgp_sym_encrypt($3, 'SLMSZ1929S')::BYTEA,
    display_name = $4,
    gender = $5,
    dob = $6,
    user_address = pgp_sym_encrypt($7, 'SLMSZ1929S')::BYTEA,
    ph_fixed = pgp_sym_encrypt($8, 'SLMSZ1929S')::BYTEA,
    ph_mobile = pgp_sym_encrypt($9, 'SLMSZ1929S')::BYTEA,
    mobile_verification = $10
WHERE
    user_id = $1
`

type UpdateUserInfoByIDParams struct {
	UserID             int64        `json:"userId"`
	PgpSymEncrypt      string       `json:"pgpSymEncrypt"`
	PgpSymEncrypt_2    string       `json:"pgpSymEncrypt2"`
	DisplayName        string       `json:"displayName"`
	Gender             SelectGender `json:"gender"`
	Dob                time.Time    `json:"dob"`
	PgpSymEncrypt_3    string       `json:"pgpSymEncrypt3"`
	PgpSymEncrypt_4    string       `json:"pgpSymEncrypt4"`
	PgpSymEncrypt_5    string       `json:"pgpSymEncrypt5"`
	MobileVerification bool         `json:"mobileVerification"`
}

func (q *Queries) UpdateUserInfoByID(ctx context.Context, arg UpdateUserInfoByIDParams) error {
	_, err := q.db.Exec(ctx, updateUserInfoByID,
		arg.UserID,
		arg.PgpSymEncrypt,
		arg.PgpSymEncrypt_2,
		arg.DisplayName,
		arg.Gender,
		arg.Dob,
		arg.PgpSymEncrypt_3,
		arg.PgpSymEncrypt_4,
		arg.PgpSymEncrypt_5,
		arg.MobileVerification,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET
    jpp_password = $2
WHERE
    user_id = $1
    AND email_id = $4
    AND jpp_password = $3
`

type UpdateUserPasswordParams struct {
	UserID        int64  `json:"userId"`
	JppPassword   string `json:"jppPassword"`
	JppPassword_2 string `json:"jppPassword2"`
	EmailID       string `json:"emailId"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword,
		arg.UserID,
		arg.JppPassword,
		arg.JppPassword_2,
		arg.EmailID,
	)
	return err
}

const updateUserPasswordByEmailIDOTP = `-- name: UpdateUserPasswordByEmailIDOTP :exec
UPDATE users
SET
    jpp_password = $2
WHERE
    email_id = $1
    AND otp_email = $3
`

type UpdateUserPasswordByEmailIDOTPParams struct {
	EmailID     string `json:"emailId"`
	JppPassword string `json:"jppPassword"`
	OtpEmail    int32  `json:"otpEmail"`
}

func (q *Queries) UpdateUserPasswordByEmailIDOTP(ctx context.Context, arg UpdateUserPasswordByEmailIDOTPParams) error {
	_, err := q.db.Exec(ctx, updateUserPasswordByEmailIDOTP, arg.EmailID, arg.JppPassword, arg.OtpEmail)
	return err
}

const updateVerifiedByOTP = `-- name: UpdateVerifiedByOTP :exec
UPDATE users
SET
    mobile_verification = TRUE
WHERE
    email_id = $1
`

func (q *Queries) UpdateVerifiedByOTP(ctx context.Context, emailID string) error {
	_, err := q.db.Exec(ctx, updateVerifiedByOTP, emailID)
	return err
}

const updateVerifiedMobileByOTP = `-- name: UpdateVerifiedMobileByOTP :exec
UPDATE users
SET
    mobile_verification = TRUE
WHERE
    cast(pgp_sym_decrypt(ph_mobile, 'SLMSZ1929S') AS VARCHAR) = cast($1 AS VARCHAR)
`

func (q *Queries) UpdateVerifiedMobileByOTP(ctx context.Context, dollar_1 string) error {
	_, err := q.db.Exec(ctx, updateVerifiedMobileByOTP, dollar_1)
	return err
}

const updateVerifyEmailByOTP = `-- name: UpdateVerifyEmailByOTP :exec
UPDATE users
SET
    email_verification = TRUE
WHERE
    email_id = $1
`

func (q *Queries) UpdateVerifyEmailByOTP(ctx context.Context, emailID string) error {
	_, err := q.db.Exec(ctx, updateVerifyEmailByOTP, emailID)
	return err
}
