// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: agenda.sql

package gen

import (
	"context"
	"time"

	database "ZenitusJPP/database"
)

const acceptanceAgendaCountByAgendaUserId = `-- name: AcceptanceAgendaCountByAgendaUserId :one
SELECT count(*) AS cnt
FROM
    agenda_acceptence
WHERE
    agenda_master_id = $1
    AND user_id = $2
`

type AcceptanceAgendaCountByAgendaUserIdParams struct {
	AgendaMasterID int64 `json:"agendaMasterId"`
	UserID         int64 `json:"userId"`
}

func (q *Queries) AcceptanceAgendaCountByAgendaUserId(ctx context.Context, arg AcceptanceAgendaCountByAgendaUserIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, acceptanceAgendaCountByAgendaUserId, arg.AgendaMasterID, arg.UserID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const agendaChoice = `-- name: AgendaChoice :one
INSERT INTO agenda_choice
(
    agenda_master_id,
    choice_text,
    display_order
) VALUES (
    $1,
    $2,
    $3
) RETURNING agenda_choice_id
`

type AgendaChoiceParams struct {
	AgendaMasterID int64  `json:"agendaMasterId"`
	ChoiceText     string `json:"choiceText"`
	DisplayOrder   int32  `json:"displayOrder"`
}

func (q *Queries) AgendaChoice(ctx context.Context, arg AgendaChoiceParams) (int64, error) {
	row := q.db.QueryRow(ctx, agendaChoice, arg.AgendaMasterID, arg.ChoiceText, arg.DisplayOrder)
	var agenda_choice_id int64
	err := row.Scan(&agenda_choice_id)
	return agenda_choice_id, err
}

const agnedaCommentDeleteByAgendaIDUserId = `-- name: AgnedaCommentDeleteByAgendaIDUserId :exec
SELECT deleteagendacomment($1, $2)
`

type AgnedaCommentDeleteByAgendaIDUserIdParams struct {
	Agendaid int64 `json:"agendaid"`
	Userid   int64 `json:"userid"`
}

func (q *Queries) AgnedaCommentDeleteByAgendaIDUserId(ctx context.Context, arg AgnedaCommentDeleteByAgendaIDUserIdParams) error {
	_, err := q.db.Exec(ctx, agnedaCommentDeleteByAgendaIDUserId, arg.Agendaid, arg.Userid)
	return err
}

const commentCountByAgendaUserId = `-- name: CommentCountByAgendaUserId :one
SELECT count(*) AS cnt
FROM
    agenda_comment
WHERE
    agenda_master_id = $1
    AND user_id = $2
    AND ref_agenda_comment_id = 0
`

type CommentCountByAgendaUserIdParams struct {
	AgendaMasterID int64 `json:"agendaMasterId"`
	UserID         int64 `json:"userId"`
}

func (q *Queries) CommentCountByAgendaUserId(ctx context.Context, arg CommentCountByAgendaUserIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, commentCountByAgendaUserId, arg.AgendaMasterID, arg.UserID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const commentDiLikeCountByCommentUserId = `-- name: CommentDiLikeCountByCommentUserId :one
SELECT count(*) AS cnt
FROM
    agenda_comment_reportlikedislike
WHERE
    agenda_comment_id = $1
    AND comment_response = 'Disliked'
    AND user_id = $2
`

type CommentDiLikeCountByCommentUserIdParams struct {
	AgendaCommentID int64 `json:"agendaCommentId"`
	UserID          int64 `json:"userId"`
}

func (q *Queries) CommentDiLikeCountByCommentUserId(ctx context.Context, arg CommentDiLikeCountByCommentUserIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, commentDiLikeCountByCommentUserId, arg.AgendaCommentID, arg.UserID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const commentLikeCountByCommentUserId = `-- name: CommentLikeCountByCommentUserId :one
SELECT count(*) AS cnt
FROM
    agenda_comment_reportlikedislike
WHERE
    agenda_comment_id = $1
    AND comment_response = 'Liked'
    AND user_id = $2
`

type CommentLikeCountByCommentUserIdParams struct {
	AgendaCommentID int64 `json:"agendaCommentId"`
	UserID          int64 `json:"userId"`
}

func (q *Queries) CommentLikeCountByCommentUserId(ctx context.Context, arg CommentLikeCountByCommentUserIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, commentLikeCountByCommentUserId, arg.AgendaCommentID, arg.UserID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const commentReplyListByCommentID = `-- name: CommentReplyListByCommentID :many
SELECT
    agenda_comment.agenda_comment_id, agenda_comment.user_id, agenda_comment.agenda_master_id, agenda_comment.comment_text, agenda_comment.created_at, agenda_comment.updated_at, agenda_comment.ref_agenda_comment_id,
    users.user_id, users.first_name, users.last_name, users.user_address, users.ph_fixed, users.ph_mobile, users.handle_name, users.display_name, users.email_id, users.token, users.gender, users.dob, users.jpp_password, users.otp, users.is_admin, users.mobile_verification, users.is_deleted, users.created_on, users.last_updated_on, users.email_verification, users.otp_email, users.payment_token, users.is_paid, users.paid_date, users.login_datetime
FROM
    agenda_comment
INNER JOIN users ON agenda_comment.user_id = users.user_id
WHERE
    agenda_comment.ref_agenda_comment_id = $1
    AND agenda_comment.agenda_master_id = $2
`

type CommentReplyListByCommentIDParams struct {
	RefAgendaCommentID int64 `json:"refAgendaCommentId"`
	AgendaMasterID     int64 `json:"agendaMasterId"`
}

type CommentReplyListByCommentIDRow struct {
	AgendaCommentID    int64             `json:"agendaCommentId"`
	UserID             int64             `json:"userId"`
	AgendaMasterID     int64             `json:"agendaMasterId"`
	CommentText        string            `json:"commentText"`
	CreatedAt          time.Time         `json:"createdAt"`
	UpdatedAt          time.Time         `json:"updatedAt"`
	RefAgendaCommentID int64             `json:"refAgendaCommentId"`
	UserID_2           int64             `json:"userId2"`
	FirstName          []byte            `json:"firstName"`
	LastName           []byte            `json:"lastName"`
	UserAddress        []byte            `json:"userAddress"`
	PhFixed            []byte            `json:"phFixed"`
	PhMobile           []byte            `json:"phMobile"`
	HandleName         []byte            `json:"handleName"`
	DisplayName        string            `json:"displayName"`
	EmailID            string            `json:"emailId"`
	Token              string            `json:"token"`
	Gender             SelectGender      `json:"gender"`
	Dob                time.Time         `json:"dob"`
	JppPassword        string            `json:"jppPassword"`
	Otp                int32             `json:"otp"`
	IsAdmin            bool              `json:"isAdmin"`
	MobileVerification bool              `json:"mobileVerification"`
	IsDeleted          bool              `json:"isDeleted"`
	CreatedOn          time.Time         `json:"createdOn"`
	LastUpdatedOn      time.Time         `json:"lastUpdatedOn"`
	EmailVerification  bool              `json:"emailVerification"`
	OtpEmail           int32             `json:"otpEmail"`
	PaymentToken       string            `json:"paymentToken"`
	IsPaid             bool              `json:"isPaid"`
	PaidDate           database.NullTime `json:"paidDate"`
	LoginDatetime      database.NullTime `json:"loginDatetime"`
}

func (q *Queries) CommentReplyListByCommentID(ctx context.Context, arg CommentReplyListByCommentIDParams) ([]*CommentReplyListByCommentIDRow, error) {
	rows, err := q.db.Query(ctx, commentReplyListByCommentID, arg.RefAgendaCommentID, arg.AgendaMasterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CommentReplyListByCommentIDRow{}
	for rows.Next() {
		var i CommentReplyListByCommentIDRow
		if err := rows.Scan(
			&i.AgendaCommentID,
			&i.UserID,
			&i.AgendaMasterID,
			&i.CommentText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefAgendaCommentID,
			&i.UserID_2,
			&i.FirstName,
			&i.LastName,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.HandleName,
			&i.DisplayName,
			&i.EmailID,
			&i.Token,
			&i.Gender,
			&i.Dob,
			&i.JppPassword,
			&i.Otp,
			&i.IsAdmin,
			&i.MobileVerification,
			&i.IsDeleted,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.EmailVerification,
			&i.OtpEmail,
			&i.PaymentToken,
			&i.IsPaid,
			&i.PaidDate,
			&i.LoginDatetime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const commentReportCountByCommentUserId = `-- name: CommentReportCountByCommentUserId :one
SELECT count(*) AS cnt
FROM
    agenda_comment_reportlikedislike
WHERE
    agenda_comment_id = $1
    AND comment_response = 'Report'
    AND user_id = $2
`

type CommentReportCountByCommentUserIdParams struct {
	AgendaCommentID int64 `json:"agendaCommentId"`
	UserID          int64 `json:"userId"`
}

func (q *Queries) CommentReportCountByCommentUserId(ctx context.Context, arg CommentReportCountByCommentUserIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, commentReportCountByCommentUserId, arg.AgendaCommentID, arg.UserID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const commentRreplyCountByAgendaUserId = `-- name: CommentRreplyCountByAgendaUserId :one
SELECT count(*) AS cnt
FROM
    agenda_comment
WHERE
    agenda_master_id = $1
    AND user_id = $2
    AND ref_agenda_comment_id = $3
`

type CommentRreplyCountByAgendaUserIdParams struct {
	AgendaMasterID     int64 `json:"agendaMasterId"`
	UserID             int64 `json:"userId"`
	RefAgendaCommentID int64 `json:"refAgendaCommentId"`
}

func (q *Queries) CommentRreplyCountByAgendaUserId(ctx context.Context, arg CommentRreplyCountByAgendaUserIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, commentRreplyCountByAgendaUserId, arg.AgendaMasterID, arg.UserID, arg.RefAgendaCommentID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const deleteLikeDislikeByUserIdAgnedaId = `-- name: DeleteLikeDislikeByUserIdAgnedaId :exec
DELETE FROM agenda_comment_reportlikedislike
WHERE
    comment_response IN ('Liked', 'Disliked')
    AND agenda_comment_id = $1
    AND user_id = $2
`

type DeleteLikeDislikeByUserIdAgnedaIdParams struct {
	AgendaCommentID int64 `json:"agendaCommentId"`
	UserID          int64 `json:"userId"`
}

func (q *Queries) DeleteLikeDislikeByUserIdAgnedaId(ctx context.Context, arg DeleteLikeDislikeByUserIdAgnedaIdParams) error {
	_, err := q.db.Exec(ctx, deleteLikeDislikeByUserIdAgnedaId, arg.AgendaCommentID, arg.UserID)
	return err
}

const deleteNotificationById = `-- name: DeleteNotificationById :exec
DELETE FROM notification
WHERE
    notification_id = $1
`

func (q *Queries) DeleteNotificationById(ctx context.Context, notificationID int64) error {
	_, err := q.db.Exec(ctx, deleteNotificationById, notificationID)
	return err
}

const getComentInfoByCommentID = `-- name: GetComentInfoByCommentID :many
SELECT
    agenda_comment_id, user_id, agenda_master_id, comment_text, created_at, updated_at, ref_agenda_comment_id
FROM
    agenda_comment
WHERE
    agenda_comment_id = $1
`

func (q *Queries) GetComentInfoByCommentID(ctx context.Context, agendaCommentID int64) ([]*AgendaComment, error) {
	rows, err := q.db.Query(ctx, getComentInfoByCommentID, agendaCommentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AgendaComment{}
	for rows.Next() {
		var i AgendaComment
		if err := rows.Scan(
			&i.AgendaCommentID,
			&i.UserID,
			&i.AgendaMasterID,
			&i.CommentText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefAgendaCommentID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGraphAgenda = `-- name: GetGraphAgenda :one
SELECT
    agenda_master_id,
    getgraphmale($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS malerecords,
    getgraphfemale($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS femalerecords,
    getgraphage1($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS agegroupa,
    getgraphage2($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS agegroupb,
    getgraphage3($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS agegroupc,
    getgraphage4($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS agegroupd,
    getgraphage5($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS agegroupe,
    getgraphage6($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS agegroupf,
    getgraphage7($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS agegroupg,
    getgraphage8($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS agegrouph
FROM
    agenda_master
WHERE
    agenda_master_id = $1
`

type GetGraphAgendaParams struct {
	Agendaid int64 `json:"agendaid"`
	Male     int32 `json:"male"`
	Female   int32 `json:"female"`
	Agea     int32 `json:"agea"`
	Ageb     int32 `json:"ageb"`
	Agec     int32 `json:"agec"`
	Aged     int32 `json:"aged"`
	Agee     int32 `json:"agee"`
	Agef     int32 `json:"agef"`
	Ageg     int32 `json:"ageg"`
	Ageh     int32 `json:"ageh"`
}

type GetGraphAgendaRow struct {
	AgendaMasterID int64 `json:"agendaMasterId"`
	Malerecords    int64 `json:"malerecords"`
	Femalerecords  int64 `json:"femalerecords"`
	Agegroupa      int64 `json:"agegroupa"`
	Agegroupb      int64 `json:"agegroupb"`
	Agegroupc      int64 `json:"agegroupc"`
	Agegroupd      int64 `json:"agegroupd"`
	Agegroupe      int64 `json:"agegroupe"`
	Agegroupf      int64 `json:"agegroupf"`
	Agegroupg      int64 `json:"agegroupg"`
	Agegrouph      int64 `json:"agegrouph"`
}

func (q *Queries) GetGraphAgenda(ctx context.Context, arg GetGraphAgendaParams) (*GetGraphAgendaRow, error) {
	row := q.db.QueryRow(ctx, getGraphAgenda,
		arg.Agendaid,
		arg.Male,
		arg.Female,
		arg.Agea,
		arg.Ageb,
		arg.Agec,
		arg.Aged,
		arg.Agee,
		arg.Agef,
		arg.Ageg,
		arg.Ageh,
	)
	var i GetGraphAgendaRow
	err := row.Scan(
		&i.AgendaMasterID,
		&i.Malerecords,
		&i.Femalerecords,
		&i.Agegroupa,
		&i.Agegroupb,
		&i.Agegroupc,
		&i.Agegroupd,
		&i.Agegroupe,
		&i.Agegroupf,
		&i.Agegroupg,
		&i.Agegrouph,
	)
	return &i, err
}

const insertAgendaAcceptance = `-- name: InsertAgendaAcceptance :one
INSERT INTO agenda_acceptence (
    user_id,
    agenda_master_id
) VALUES (
    $1,
    $2
) RETURNING agenda_acceptence_id
`

type InsertAgendaAcceptanceParams struct {
	UserID         int64 `json:"userId"`
	AgendaMasterID int64 `json:"agendaMasterId"`
}

func (q *Queries) InsertAgendaAcceptance(ctx context.Context, arg InsertAgendaAcceptanceParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgendaAcceptance, arg.UserID, arg.AgendaMasterID)
	var agenda_acceptence_id int64
	err := row.Scan(&agenda_acceptence_id)
	return agenda_acceptence_id, err
}

const insertAgendaComment = `-- name: InsertAgendaComment :one
INSERT INTO agenda_comment (
    user_id,
    agenda_master_id,
    comment_text
) VALUES (
    $1,
    $2,
    $3
) RETURNING agenda_comment_id
`

type InsertAgendaCommentParams struct {
	UserID         int64  `json:"userId"`
	AgendaMasterID int64  `json:"agendaMasterId"`
	CommentText    string `json:"commentText"`
}

func (q *Queries) InsertAgendaComment(ctx context.Context, arg InsertAgendaCommentParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgendaComment, arg.UserID, arg.AgendaMasterID, arg.CommentText)
	var agenda_comment_id int64
	err := row.Scan(&agenda_comment_id)
	return agenda_comment_id, err
}

const insertAgendaCommentDisLike = `-- name: InsertAgendaCommentDisLike :one
INSERT INTO agenda_comment_reportlikedislike (
    user_id,
    agenda_comment_id,
    comment_response
) VALUES (
    $1,
    $2,
    'Disliked'
) RETURNING agenda_comment_rll
`

type InsertAgendaCommentDisLikeParams struct {
	UserID          int64 `json:"userId"`
	AgendaCommentID int64 `json:"agendaCommentId"`
}

func (q *Queries) InsertAgendaCommentDisLike(ctx context.Context, arg InsertAgendaCommentDisLikeParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgendaCommentDisLike, arg.UserID, arg.AgendaCommentID)
	var agenda_comment_rll int64
	err := row.Scan(&agenda_comment_rll)
	return agenda_comment_rll, err
}

const insertAgendaCommentLike = `-- name: InsertAgendaCommentLike :one
INSERT INTO agenda_comment_reportlikedislike (
    user_id,
    agenda_comment_id,
    comment_response
) VALUES (
    $1,
    $2,
    'Liked'
) RETURNING agenda_comment_rll
`

type InsertAgendaCommentLikeParams struct {
	UserID          int64 `json:"userId"`
	AgendaCommentID int64 `json:"agendaCommentId"`
}

func (q *Queries) InsertAgendaCommentLike(ctx context.Context, arg InsertAgendaCommentLikeParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgendaCommentLike, arg.UserID, arg.AgendaCommentID)
	var agenda_comment_rll int64
	err := row.Scan(&agenda_comment_rll)
	return agenda_comment_rll, err
}

const insertAgendaCommentReply = `-- name: InsertAgendaCommentReply :one
INSERT INTO agenda_comment (
    user_id,
    agenda_master_id,
    comment_text,
    ref_agenda_comment_id
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING agenda_comment_id
`

type InsertAgendaCommentReplyParams struct {
	UserID             int64  `json:"userId"`
	AgendaMasterID     int64  `json:"agendaMasterId"`
	CommentText        string `json:"commentText"`
	RefAgendaCommentID int64  `json:"refAgendaCommentId"`
}

func (q *Queries) InsertAgendaCommentReply(ctx context.Context, arg InsertAgendaCommentReplyParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgendaCommentReply,
		arg.UserID,
		arg.AgendaMasterID,
		arg.CommentText,
		arg.RefAgendaCommentID,
	)
	var agenda_comment_id int64
	err := row.Scan(&agenda_comment_id)
	return agenda_comment_id, err
}

const insertAgendaCommentReport = `-- name: InsertAgendaCommentReport :one
INSERT INTO agenda_comment_reportlikedislike (
    user_id,
    agenda_comment_id,
    comment_response
) VALUES (
    $1,
    $2,
    'Report'
) RETURNING agenda_comment_rll
`

type InsertAgendaCommentReportParams struct {
	UserID          int64 `json:"userId"`
	AgendaCommentID int64 `json:"agendaCommentId"`
}

func (q *Queries) InsertAgendaCommentReport(ctx context.Context, arg InsertAgendaCommentReportParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgendaCommentReport, arg.UserID, arg.AgendaCommentID)
	var agenda_comment_rll int64
	err := row.Scan(&agenda_comment_rll)
	return agenda_comment_rll, err
}

const insertAgendaInfo = `-- name: InsertAgendaInfo :one
INSERT INTO agenda_master (
    topic_name,
    location_level,
    discussion_details,
    is_approved,
    is_deleted,
    user_id
)
VALUES (
    $1,
    $2,
    $3,
    FALSE,
    FALSE,
    $4
) RETURNING agenda_master_id
`

type InsertAgendaInfoParams struct {
	TopicName         string          `json:"topicName"`
	LocationLevel     SelectLocations `json:"locationLevel"`
	DiscussionDetails string          `json:"discussionDetails"`
	UserID            int64           `json:"userId"`
}

func (q *Queries) InsertAgendaInfo(ctx context.Context, arg InsertAgendaInfoParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgendaInfo,
		arg.TopicName,
		arg.LocationLevel,
		arg.DiscussionDetails,
		arg.UserID,
	)
	var agenda_master_id int64
	err := row.Scan(&agenda_master_id)
	return agenda_master_id, err
}

const insertAgendaVote = `-- name: InsertAgendaVote :one
INSERT INTO agenda_vote (
    user_id,
    agenda_master_id,
    agenda_choice_id
) VALUES (
    $1,
    $2,
    $3
) RETURNING agenda_vote_id
`

type InsertAgendaVoteParams struct {
	UserID         int64 `json:"userId"`
	AgendaMasterID int64 `json:"agendaMasterId"`
	AgendaChoiceID int64 `json:"agendaChoiceId"`
}

func (q *Queries) InsertAgendaVote(ctx context.Context, arg InsertAgendaVoteParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertAgendaVote, arg.UserID, arg.AgendaMasterID, arg.AgendaChoiceID)
	var agenda_vote_id int64
	err := row.Scan(&agenda_vote_id)
	return agenda_vote_id, err
}

const insertPartyInquiry = `-- name: InsertPartyInquiry :one
INSERT INTO inquiry
(
    user_name,
    email_id,
    message_content
)
VALUES
(
    $1,
    $2,
    $3
)
RETURNING inquiry_id
`

type InsertPartyInquiryParams struct {
	UserName       string `json:"userName"`
	EmailID        string `json:"emailId"`
	MessageContent string `json:"messageContent"`
}

func (q *Queries) InsertPartyInquiry(ctx context.Context, arg InsertPartyInquiryParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertPartyInquiry, arg.UserName, arg.EmailID, arg.MessageContent)
	var inquiry_id int64
	err := row.Scan(&inquiry_id)
	return inquiry_id, err
}

const insertagendachoice = `-- name: Insertagendachoice :one
INSERT INTO agenda_choice (
    agenda_master_id,
    choice_id,
    choice_text
)
VALUES (
    $1,
    $2,
    $3
) RETURNING agenda_choice_id
`

type InsertagendachoiceParams struct {
	AgendaMasterID int64  `json:"agendaMasterId"`
	ChoiceID       string `json:"choiceId"`
	ChoiceText     string `json:"choiceText"`
}

func (q *Queries) Insertagendachoice(ctx context.Context, arg InsertagendachoiceParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertagendachoice, arg.AgendaMasterID, arg.ChoiceID, arg.ChoiceText)
	var agenda_choice_id int64
	err := row.Scan(&agenda_choice_id)
	return agenda_choice_id, err
}

const notificationByUserId = `-- name: NotificationByUserId :many
SELECT
    notification.notification_id, notification.user_id, notification.notification_text, notification.created_at, notification.is_deleted
FROM
    notification
WHERE
    notification.user_id = $1
    AND notification.is_deleted = FALSE
ORDER BY
    notification.created_at DESC
`

func (q *Queries) NotificationByUserId(ctx context.Context, userID int64) ([]*Notification, error) {
	rows, err := q.db.Query(ctx, notificationByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.NotificationID,
			&i.UserID,
			&i.NotificationText,
			&i.CreatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notificationInsert = `-- name: NotificationInsert :one
INSERT INTO notification
(
    user_id,
    notification_text
)
VALUES (
    $1,
    $2
) RETURNING notification_id
`

type NotificationInsertParams struct {
	UserID           int64  `json:"userId"`
	NotificationText string `json:"notificationText"`
}

func (q *Queries) NotificationInsert(ctx context.Context, arg NotificationInsertParams) (int64, error) {
	row := q.db.QueryRow(ctx, notificationInsert, arg.UserID, arg.NotificationText)
	var notification_id int64
	err := row.Scan(&notification_id)
	return notification_id, err
}

const selectAgenda = `-- name: SelectAgenda :many
SELECT
    agenda_master_id,
    topic_name,
    location_level,
    discussion_details,
    is_approved,
    is_deleted
FROM
    agenda_master
WHERE
    is_deleted = FALSE
`

type SelectAgendaRow struct {
	AgendaMasterID    int64           `json:"agendaMasterId"`
	TopicName         string          `json:"topicName"`
	LocationLevel     SelectLocations `json:"locationLevel"`
	DiscussionDetails string          `json:"discussionDetails"`
	IsApproved        bool            `json:"isApproved"`
	IsDeleted         bool            `json:"isDeleted"`
}

func (q *Queries) SelectAgenda(ctx context.Context) ([]*SelectAgendaRow, error) {
	rows, err := q.db.Query(ctx, selectAgenda)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAgendaRow{}
	for rows.Next() {
		var i SelectAgendaRow
		if err := rows.Scan(
			&i.AgendaMasterID,
			&i.TopicName,
			&i.LocationLevel,
			&i.DiscussionDetails,
			&i.IsApproved,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAgendaAllInfo = `-- name: SelectAgendaAllInfo :many
SELECT
    agenda_master.agenda_master_id,
    agenda_master.user_id,
    agenda_master.topic_name,
    agenda_master.location_level,
    agenda_master.discussion_details,
    agenda_master.is_approved,
    agenda_master.is_deleted,
    agenda_master.created_at,
    agenda_master.updated_at,
    users.display_name,
    users.email_id,
    users.gender,
    users.dob,
    users.jpp_password,
    users.otp,
    users.is_admin,
    users.mobile_verification,
    users.is_deleted AS user_is_deleted,
    users.email_verification,
    users.otp_email,
    users.is_paid,
    users.paid_date,
    cast(pgp_sym_decrypt(users.first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(users.last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(users.user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(users.ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(users.handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name
FROM
    agenda_master
INNER JOIN
    users ON agenda_master.user_id = users.user_id
WHERE
    agenda_master.is_deleted = FALSE
`

type SelectAgendaAllInfoRow struct {
	AgendaMasterID     int64             `json:"agendaMasterId"`
	UserID             int64             `json:"userId"`
	TopicName          string            `json:"topicName"`
	LocationLevel      SelectLocations   `json:"locationLevel"`
	DiscussionDetails  string            `json:"discussionDetails"`
	IsApproved         bool              `json:"isApproved"`
	IsDeleted          bool              `json:"isDeleted"`
	CreatedAt          time.Time         `json:"createdAt"`
	UpdatedAt          time.Time         `json:"updatedAt"`
	DisplayName        string            `json:"displayName"`
	EmailID            string            `json:"emailId"`
	Gender             SelectGender      `json:"gender"`
	Dob                time.Time         `json:"dob"`
	JppPassword        string            `json:"jppPassword"`
	Otp                int32             `json:"otp"`
	IsAdmin            bool              `json:"isAdmin"`
	MobileVerification bool              `json:"mobileVerification"`
	UserIsDeleted      bool              `json:"userIsDeleted"`
	EmailVerification  bool              `json:"emailVerification"`
	OtpEmail           int32             `json:"otpEmail"`
	IsPaid             bool              `json:"isPaid"`
	PaidDate           database.NullTime `json:"paidDate"`
	FirstName          string            `json:"firstName"`
	LastName           string            `json:"lastName"`
	UserAddress        string            `json:"userAddress"`
	PhFixed            string            `json:"phFixed"`
	PhMobile           string            `json:"phMobile"`
	HandleName         string            `json:"handleName"`
}

func (q *Queries) SelectAgendaAllInfo(ctx context.Context) ([]*SelectAgendaAllInfoRow, error) {
	rows, err := q.db.Query(ctx, selectAgendaAllInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAgendaAllInfoRow{}
	for rows.Next() {
		var i SelectAgendaAllInfoRow
		if err := rows.Scan(
			&i.AgendaMasterID,
			&i.UserID,
			&i.TopicName,
			&i.LocationLevel,
			&i.DiscussionDetails,
			&i.IsApproved,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisplayName,
			&i.EmailID,
			&i.Gender,
			&i.Dob,
			&i.JppPassword,
			&i.Otp,
			&i.IsAdmin,
			&i.MobileVerification,
			&i.UserIsDeleted,
			&i.EmailVerification,
			&i.OtpEmail,
			&i.IsPaid,
			&i.PaidDate,
			&i.FirstName,
			&i.LastName,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.HandleName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAgendaAllInfoAdmin = `-- name: SelectAgendaAllInfoAdmin :many
WITH precount AS ( --noqa: L022
    SELECT
        agenda_master_id AS amid,
        count(*) AS cnt
    FROM
        agenda_acceptence
    GROUP BY
        agenda_master_id
), commentcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS c_amid,
        count(*) AS c_cnt
    FROM
        agenda_comment
    GROUP BY
        agenda_master_id
), optionacount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pa_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pa_cnt,
        max(choice_text) AS pa_text,
        max(agenda_choice_id) AS pa_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_one'
    GROUP BY
        agenda_master_id
), optionbcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pb_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pb_cnt,
        max(choice_text) AS pb_text,
        max(agenda_choice_id) AS pb_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_two'
    GROUP BY
        agenda_master_id
), optionccount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pc_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pc_cnt,
        max(choice_text) AS pc_text,
        max(agenda_choice_id) AS pc_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_three'
    GROUP BY
        agenda_master_id
), optiondcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pd_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pd_cnt,
        max(choice_text) AS pd_text,
        max(agenda_choice_id) AS pd_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_four'
    GROUP BY
        agenda_master_id
), optionecount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pe_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pe_cnt,
        max(choice_text) AS pe_text,
        max(agenda_choice_id) AS pe_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_five'
    GROUP BY
        agenda_master_id
), optionfcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pf_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pf_cnt,
        max(choice_text) AS pf_text,
        max(agenda_choice_id) AS pf_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_six'
    GROUP BY
        agenda_master_id
) SELECT --noqa: L022
    agenda_master.agenda_master_id,
    agenda_master.user_id,
    agenda_master.topic_name,
    agenda_master.location_level,
    agenda_master.discussion_details,
    agenda_master.is_approved,
    agenda_master.is_deleted,
    agenda_master.created_at,
    agenda_master.updated_at,
    users.display_name,
    users.email_id,
    users.gender,
    users.dob,
    users.jpp_password,
    users.otp,
    users.is_admin,
    users.mobile_verification,
    users.is_deleted AS user_is_deleted,
    users.email_verification,
    users.otp_email,
    users.is_paid,
    users.paid_date,
    cast(pgp_sym_decrypt(users.first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(users.last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(users.user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(users.ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(users.handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name,
    coalesce(precount.cnt, 0) AS acceptancecount,
    coalesce(commentcount.c_cnt, 0) AS commentcount,
    coalesce(optionacount.pa_cnt, 0) AS choicea_count,
    coalesce(optionacount.pa_text, '') AS choicea_text,
    coalesce(optionacount.pa_choice_id, 0) AS choicea_choice_id,
    coalesce(optionbcount.pb_cnt, 0) AS choiceb_count,
    coalesce(optionbcount.pb_text, '') AS choiceb_text,
    coalesce(optionbcount.pb_choice_id, 0) AS choiceb_choice_id,
    coalesce(optionccount.pc_cnt, 0) AS choicec_count,
    coalesce(optionccount.pc_text, '') AS choicec_text,
    coalesce(optionccount.pc_choice_id, 0) AS choicec_choice_id,
    coalesce(optiondcount.pd_cnt, 0) AS choiced_count,
    coalesce(optiondcount.pd_text, '') AS choiced_text,
    coalesce(optiondcount.pd_choice_id, 0) AS choiced_choice_id,
    coalesce(optionecount.pe_cnt, 0) AS choicee_count,
    coalesce(optionecount.pe_text, '') AS choicee_text,
    coalesce(optionecount.pe_choice_id, 0) AS choicee_choice_id,
    coalesce(optionfcount.pf_cnt, 0) AS choicef_count,
    coalesce(optionfcount.pf_text, '') AS choicef_text,
    coalesce(optionfcount.pf_choice_id, 0) AS choicef_choice_id
FROM
    agenda_master
INNER JOIN users ON agenda_master.user_id = users.user_id
INNER JOIN precount ON agenda_master.agenda_master_id = precount.amid
LEFT JOIN commentcount ON agenda_master.agenda_master_id = commentcount.c_amid
LEFT JOIN optionacount ON agenda_master.agenda_master_id = optionacount.pa_amid
LEFT JOIN optionbcount ON agenda_master.agenda_master_id = optionbcount.pb_amid
LEFT JOIN optionccount ON agenda_master.agenda_master_id = optionccount.pc_amid
LEFT JOIN optiondcount ON agenda_master.agenda_master_id = optiondcount.pd_amid
LEFT JOIN optionecount ON agenda_master.agenda_master_id = optionecount.pe_amid
LEFT JOIN optionfcount ON agenda_master.agenda_master_id = optionfcount.pf_amid
WHERE
    agenda_master.is_deleted = FALSE
`

type SelectAgendaAllInfoAdminRow struct {
	AgendaMasterID     int64             `json:"agendaMasterId"`
	UserID             int64             `json:"userId"`
	TopicName          string            `json:"topicName"`
	LocationLevel      SelectLocations   `json:"locationLevel"`
	DiscussionDetails  string            `json:"discussionDetails"`
	IsApproved         bool              `json:"isApproved"`
	IsDeleted          bool              `json:"isDeleted"`
	CreatedAt          time.Time         `json:"createdAt"`
	UpdatedAt          time.Time         `json:"updatedAt"`
	DisplayName        string            `json:"displayName"`
	EmailID            string            `json:"emailId"`
	Gender             SelectGender      `json:"gender"`
	Dob                time.Time         `json:"dob"`
	JppPassword        string            `json:"jppPassword"`
	Otp                int32             `json:"otp"`
	IsAdmin            bool              `json:"isAdmin"`
	MobileVerification bool              `json:"mobileVerification"`
	UserIsDeleted      bool              `json:"userIsDeleted"`
	EmailVerification  bool              `json:"emailVerification"`
	OtpEmail           int32             `json:"otpEmail"`
	IsPaid             bool              `json:"isPaid"`
	PaidDate           database.NullTime `json:"paidDate"`
	FirstName          string            `json:"firstName"`
	LastName           string            `json:"lastName"`
	UserAddress        string            `json:"userAddress"`
	PhFixed            string            `json:"phFixed"`
	PhMobile           string            `json:"phMobile"`
	HandleName         string            `json:"handleName"`
	Acceptancecount    int64             `json:"acceptancecount"`
	Commentcount       int64             `json:"commentcount"`
	ChoiceaCount       int32             `json:"choiceaCount"`
	ChoiceaText        interface{}       `json:"choiceaText"`
	ChoiceaChoiceID    interface{}       `json:"choiceaChoiceId"`
	ChoicebCount       int32             `json:"choicebCount"`
	ChoicebText        interface{}       `json:"choicebText"`
	ChoicebChoiceID    interface{}       `json:"choicebChoiceId"`
	ChoicecCount       int32             `json:"choicecCount"`
	ChoicecText        interface{}       `json:"choicecText"`
	ChoicecChoiceID    interface{}       `json:"choicecChoiceId"`
	ChoicedCount       int32             `json:"choicedCount"`
	ChoicedText        interface{}       `json:"choicedText"`
	ChoicedChoiceID    interface{}       `json:"choicedChoiceId"`
	ChoiceeCount       int32             `json:"choiceeCount"`
	ChoiceeText        interface{}       `json:"choiceeText"`
	ChoiceeChoiceID    interface{}       `json:"choiceeChoiceId"`
	ChoicefCount       int32             `json:"choicefCount"`
	ChoicefText        interface{}       `json:"choicefText"`
	ChoicefChoiceID    interface{}       `json:"choicefChoiceId"`
}

func (q *Queries) SelectAgendaAllInfoAdmin(ctx context.Context) ([]*SelectAgendaAllInfoAdminRow, error) {
	rows, err := q.db.Query(ctx, selectAgendaAllInfoAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAgendaAllInfoAdminRow{}
	for rows.Next() {
		var i SelectAgendaAllInfoAdminRow
		if err := rows.Scan(
			&i.AgendaMasterID,
			&i.UserID,
			&i.TopicName,
			&i.LocationLevel,
			&i.DiscussionDetails,
			&i.IsApproved,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisplayName,
			&i.EmailID,
			&i.Gender,
			&i.Dob,
			&i.JppPassword,
			&i.Otp,
			&i.IsAdmin,
			&i.MobileVerification,
			&i.UserIsDeleted,
			&i.EmailVerification,
			&i.OtpEmail,
			&i.IsPaid,
			&i.PaidDate,
			&i.FirstName,
			&i.LastName,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.HandleName,
			&i.Acceptancecount,
			&i.Commentcount,
			&i.ChoiceaCount,
			&i.ChoiceaText,
			&i.ChoiceaChoiceID,
			&i.ChoicebCount,
			&i.ChoicebText,
			&i.ChoicebChoiceID,
			&i.ChoicecCount,
			&i.ChoicecText,
			&i.ChoicecChoiceID,
			&i.ChoicedCount,
			&i.ChoicedText,
			&i.ChoicedChoiceID,
			&i.ChoiceeCount,
			&i.ChoiceeText,
			&i.ChoiceeChoiceID,
			&i.ChoicefCount,
			&i.ChoicefText,
			&i.ChoicefChoiceID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAgendaAllInfoBackup = `-- name: SelectAgendaAllInfoBackup :many
SELECT
    agenda_master_id,
    topic_name,
    location_level,
    discussion_details,
    is_approved,
    is_deleted
FROM
    agenda_master
`

type SelectAgendaAllInfoBackupRow struct {
	AgendaMasterID    int64           `json:"agendaMasterId"`
	TopicName         string          `json:"topicName"`
	LocationLevel     SelectLocations `json:"locationLevel"`
	DiscussionDetails string          `json:"discussionDetails"`
	IsApproved        bool            `json:"isApproved"`
	IsDeleted         bool            `json:"isDeleted"`
}

func (q *Queries) SelectAgendaAllInfoBackup(ctx context.Context) ([]*SelectAgendaAllInfoBackupRow, error) {
	rows, err := q.db.Query(ctx, selectAgendaAllInfoBackup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAgendaAllInfoBackupRow{}
	for rows.Next() {
		var i SelectAgendaAllInfoBackupRow
		if err := rows.Scan(
			&i.AgendaMasterID,
			&i.TopicName,
			&i.LocationLevel,
			&i.DiscussionDetails,
			&i.IsApproved,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAgendaApproved = `-- name: SelectAgendaApproved :many
WITH precount AS (
    SELECT
        agenda_master_id AS amid,
        count(*) AS cnt
    FROM
        agenda_acceptence
    GROUP BY
        agenda_master_id
), commentcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS c_amid,
        count(*) AS c_cnt
    FROM
        agenda_comment
    GROUP BY
        agenda_master_id
), optionacount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pa_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pa_cnt,
        max(choice_text) AS pa_text
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_one'
    GROUP BY
        agenda_master_id
), optionbcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pb_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pb_cnt,
        max(choice_text) AS pb_text
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_two'
    GROUP BY
        agenda_master_id
), optionccount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pc_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pc_cnt,
        max(choice_text) AS pc_text
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_three'
    GROUP BY
        agenda_master_id
), optiondcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pd_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pd_cnt,
        max(choice_text) AS pd_text
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_four'
    GROUP BY
        agenda_master_id
), optionecount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pe_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pe_cnt,
        max(choice_text) AS pe_text
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_five'
    GROUP BY
        agenda_master_id
), optionfcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pf_amid,
        getchoicevote(max(agenda_choice_id), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) AS pf_cnt,
        max(choice_text) AS pf_text
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_six'
    GROUP BY
        agenda_master_id
) SELECT --noqa: L022
    agenda_master.agenda_master_id,
    agenda_master.topic_name,
    agenda_master.location_level,
    agenda_master.discussion_details,
    agenda_master.is_approved,
    agenda_master.is_deleted,
    coalesce(precount.cnt, 0) AS acceptancecount,
    coalesce(commentcount.c_cnt, 0) AS commentcount,
    coalesce(optionacount.pa_cnt, 0) AS choicea_count,
    coalesce(optionacount.pa_text, '') AS choicea_text,
    coalesce(optionbcount.pb_cnt, 0) AS choiceb_count,
    coalesce(optionbcount.pb_text, '') AS choiceb_text,
    coalesce(optionccount.pc_cnt, 0) AS choicec_count,
    coalesce(optionccount.pc_text, '') AS choicec_text,
    coalesce(optiondcount.pd_cnt, 0) AS choiced_count,
    coalesce(optiondcount.pd_text, '') AS choiced_text,
    coalesce(optionecount.pe_cnt, 0) AS choicee_count,
    coalesce(optionecount.pe_text, '') AS choicee_text,
    coalesce(optionfcount.pf_cnt, 0) AS choicef_count,
    coalesce(optionfcount.pf_text, '') AS choicef_text
FROM
    agenda_master
INNER JOIN precount ON agenda_master.agenda_master_id = precount.amid
LEFT JOIN commentcount ON agenda_master.agenda_master_id = commentcount.c_amid
LEFT JOIN optionacount ON agenda_master.agenda_master_id = optionacount.pa_amid
LEFT JOIN optionbcount ON agenda_master.agenda_master_id = optionbcount.pb_amid
LEFT JOIN optionccount ON agenda_master.agenda_master_id = optionccount.pc_amid
LEFT JOIN optiondcount ON agenda_master.agenda_master_id = optiondcount.pd_amid
LEFT JOIN optionecount ON agenda_master.agenda_master_id = optionecount.pe_amid
LEFT JOIN optionfcount ON agenda_master.agenda_master_id = optionfcount.pf_amid
WHERE
    (
        precount.cnt > 10
        OR agenda_master.is_approved = TRUE
    )
    AND (
        agenda_master.location_level = $1
        OR agenda_master.location_level = $2
        OR agenda_master.location_level = $3
    )
ORDER BY coalesce(precount.cnt, 0) DESC
`

type SelectAgendaApprovedParams struct {
	LocationLevel   SelectLocations `json:"locationLevel"`
	LocationLevel_2 SelectLocations `json:"locationLevel2"`
	LocationLevel_3 SelectLocations `json:"locationLevel3"`
}

type SelectAgendaApprovedRow struct {
	AgendaMasterID    int64           `json:"agendaMasterId"`
	TopicName         string          `json:"topicName"`
	LocationLevel     SelectLocations `json:"locationLevel"`
	DiscussionDetails string          `json:"discussionDetails"`
	IsApproved        bool            `json:"isApproved"`
	IsDeleted         bool            `json:"isDeleted"`
	Acceptancecount   int64           `json:"acceptancecount"`
	Commentcount      int64           `json:"commentcount"`
	ChoiceaCount      int32           `json:"choiceaCount"`
	ChoiceaText       interface{}     `json:"choiceaText"`
	ChoicebCount      int32           `json:"choicebCount"`
	ChoicebText       interface{}     `json:"choicebText"`
	ChoicecCount      int32           `json:"choicecCount"`
	ChoicecText       interface{}     `json:"choicecText"`
	ChoicedCount      int32           `json:"choicedCount"`
	ChoicedText       interface{}     `json:"choicedText"`
	ChoiceeCount      int32           `json:"choiceeCount"`
	ChoiceeText       interface{}     `json:"choiceeText"`
	ChoicefCount      int32           `json:"choicefCount"`
	ChoicefText       interface{}     `json:"choicefText"`
}

func (q *Queries) SelectAgendaApproved(ctx context.Context, arg SelectAgendaApprovedParams) ([]*SelectAgendaApprovedRow, error) {
	rows, err := q.db.Query(ctx, selectAgendaApproved, arg.LocationLevel, arg.LocationLevel_2, arg.LocationLevel_3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAgendaApprovedRow{}
	for rows.Next() {
		var i SelectAgendaApprovedRow
		if err := rows.Scan(
			&i.AgendaMasterID,
			&i.TopicName,
			&i.LocationLevel,
			&i.DiscussionDetails,
			&i.IsApproved,
			&i.IsDeleted,
			&i.Acceptancecount,
			&i.Commentcount,
			&i.ChoiceaCount,
			&i.ChoiceaText,
			&i.ChoicebCount,
			&i.ChoicebText,
			&i.ChoicecCount,
			&i.ChoicecText,
			&i.ChoicedCount,
			&i.ChoicedText,
			&i.ChoiceeCount,
			&i.ChoiceeText,
			&i.ChoicefCount,
			&i.ChoicefText,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAgendaApprovedByID = `-- name: SelectAgendaApprovedByID :many
WITH precount AS ( --noqa: L022
    SELECT
        agenda_master_id AS amid,
        count(*) AS cnt
    FROM
        agenda_acceptence
    GROUP BY
        agenda_master_id
), commentcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS c_amid,
        count(*) AS c_cnt
    FROM
        agenda_comment
    GROUP BY
        agenda_master_id
), optionacount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pa_amid,
        getchoicevote(max(agenda_choice_id), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS pa_cnt,
        max(choice_text) AS pa_text,
        max(agenda_choice_id) AS pa_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_one'
    GROUP BY
        agenda_master_id
), optionbcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pb_amid,
        getchoicevote(max(agenda_choice_id), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS pb_cnt,
        max(choice_text) AS pb_text,
        max(agenda_choice_id) AS pb_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_two'
    GROUP BY
        agenda_master_id
), optionccount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pc_amid,
        getchoicevote(max(agenda_choice_id), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS pc_cnt,
        max(choice_text) AS pc_text,
        max(agenda_choice_id) AS pc_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_three'
    GROUP BY
        agenda_master_id
), optiondcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pd_amid,
        getchoicevote(max(agenda_choice_id), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS pd_cnt,
        max(choice_text) AS pd_text,
        max(agenda_choice_id) AS pd_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_four'
    GROUP BY
        agenda_master_id
), optionecount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pe_amid,
        getchoicevote(max(agenda_choice_id), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS pe_cnt,
        max(choice_text) AS pe_text,
        max(agenda_choice_id) AS pe_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_five'
    GROUP BY
        agenda_master_id
), optionfcount AS ( --noqa: L022
    SELECT
        agenda_master_id AS pf_amid,
        getchoicevote(max(agenda_choice_id), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) AS pf_cnt,
        max(choice_text) AS pf_text,
        max(agenda_choice_id) AS pf_choice_id
    FROM
        agenda_choice
    WHERE
        choice_id = 'choice_six'
    GROUP BY
        agenda_master_id
) SELECT --noqa: L022
    agenda_master.agenda_master_id,
    agenda_master.topic_name,
    agenda_master.location_level,
    agenda_master.discussion_details,
    agenda_master.is_approved,
    agenda_master.is_deleted,
    coalesce(precount.cnt, 0) AS acceptancecount,
    coalesce(commentcount.c_cnt, 0) AS commentcount,
    coalesce(optionacount.pa_cnt, 0) AS choicea_count,
    coalesce(optionacount.pa_text, '') AS choicea_text,
    coalesce(optionacount.pa_choice_id, 0) AS choicea_choice_id,
    coalesce(optionbcount.pb_cnt, 0) AS choiceb_count,
    coalesce(optionbcount.pb_text, '') AS choiceb_text,
    coalesce(optionbcount.pb_choice_id, 0) AS choiceb_choice_id,
    coalesce(optionccount.pc_cnt, 0) AS choicec_count,
    coalesce(optionccount.pc_text, '') AS choicec_text,
    coalesce(optionccount.pc_choice_id, 0) AS choicec_choice_id,
    coalesce(optiondcount.pd_cnt, 0) AS choiced_count,
    coalesce(optiondcount.pd_text, '') AS choiced_text,
    coalesce(optiondcount.pd_choice_id, 0) AS choiced_choice_id,
    coalesce(optionecount.pe_cnt, 0) AS choicee_count,
    coalesce(optionecount.pe_text, '') AS choicee_text,
    coalesce(optionecount.pe_choice_id, 0) AS choicee_choice_id,
    coalesce(optionfcount.pf_cnt, 0) AS choicef_count,
    coalesce(optionfcount.pf_text, '') AS choicef_text,
    coalesce(optionfcount.pf_choice_id, 0) AS choicef_choice_id
FROM
    agenda_master
INNER JOIN precount ON agenda_master.agenda_master_id = precount.amid
LEFT JOIN commentcount ON agenda_master.agenda_master_id = commentcount.c_amid
LEFT JOIN optionacount ON agenda_master.agenda_master_id = optionacount.pa_amid
LEFT JOIN optionbcount ON agenda_master.agenda_master_id = optionbcount.pb_amid
LEFT JOIN optionccount ON agenda_master.agenda_master_id = optionccount.pc_amid
LEFT JOIN optiondcount ON agenda_master.agenda_master_id = optiondcount.pd_amid
LEFT JOIN optionecount ON agenda_master.agenda_master_id = optionecount.pe_amid
LEFT JOIN optionfcount ON agenda_master.agenda_master_id = optionfcount.pf_amid
WHERE
    agenda_master.agenda_master_id = $1
ORDER BY coalesce(precount.cnt, 0) DESC
`

type SelectAgendaApprovedByIDParams struct {
	AgendaMasterID int64 `json:"agendaMasterId"`
	Male           int32 `json:"male"`
	Female         int32 `json:"female"`
	Agea           int32 `json:"agea"`
	Ageb           int32 `json:"ageb"`
	Agec           int32 `json:"agec"`
	Aged           int32 `json:"aged"`
	Agee           int32 `json:"agee"`
	Agef           int32 `json:"agef"`
	Ageg           int32 `json:"ageg"`
	Ageh           int32 `json:"ageh"`
}

type SelectAgendaApprovedByIDRow struct {
	AgendaMasterID    int64           `json:"agendaMasterId"`
	TopicName         string          `json:"topicName"`
	LocationLevel     SelectLocations `json:"locationLevel"`
	DiscussionDetails string          `json:"discussionDetails"`
	IsApproved        bool            `json:"isApproved"`
	IsDeleted         bool            `json:"isDeleted"`
	Acceptancecount   int64           `json:"acceptancecount"`
	Commentcount      int64           `json:"commentcount"`
	ChoiceaCount      int32           `json:"choiceaCount"`
	ChoiceaText       interface{}     `json:"choiceaText"`
	ChoiceaChoiceID   interface{}     `json:"choiceaChoiceId"`
	ChoicebCount      int32           `json:"choicebCount"`
	ChoicebText       interface{}     `json:"choicebText"`
	ChoicebChoiceID   interface{}     `json:"choicebChoiceId"`
	ChoicecCount      int32           `json:"choicecCount"`
	ChoicecText       interface{}     `json:"choicecText"`
	ChoicecChoiceID   interface{}     `json:"choicecChoiceId"`
	ChoicedCount      int32           `json:"choicedCount"`
	ChoicedText       interface{}     `json:"choicedText"`
	ChoicedChoiceID   interface{}     `json:"choicedChoiceId"`
	ChoiceeCount      int32           `json:"choiceeCount"`
	ChoiceeText       interface{}     `json:"choiceeText"`
	ChoiceeChoiceID   interface{}     `json:"choiceeChoiceId"`
	ChoicefCount      int32           `json:"choicefCount"`
	ChoicefText       interface{}     `json:"choicefText"`
	ChoicefChoiceID   interface{}     `json:"choicefChoiceId"`
}

func (q *Queries) SelectAgendaApprovedByID(ctx context.Context, arg SelectAgendaApprovedByIDParams) ([]*SelectAgendaApprovedByIDRow, error) {
	rows, err := q.db.Query(ctx, selectAgendaApprovedByID,
		arg.AgendaMasterID,
		arg.Male,
		arg.Female,
		arg.Agea,
		arg.Ageb,
		arg.Agec,
		arg.Aged,
		arg.Agee,
		arg.Agef,
		arg.Ageg,
		arg.Ageh,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAgendaApprovedByIDRow{}
	for rows.Next() {
		var i SelectAgendaApprovedByIDRow
		if err := rows.Scan(
			&i.AgendaMasterID,
			&i.TopicName,
			&i.LocationLevel,
			&i.DiscussionDetails,
			&i.IsApproved,
			&i.IsDeleted,
			&i.Acceptancecount,
			&i.Commentcount,
			&i.ChoiceaCount,
			&i.ChoiceaText,
			&i.ChoiceaChoiceID,
			&i.ChoicebCount,
			&i.ChoicebText,
			&i.ChoicebChoiceID,
			&i.ChoicecCount,
			&i.ChoicecText,
			&i.ChoicecChoiceID,
			&i.ChoicedCount,
			&i.ChoicedText,
			&i.ChoicedChoiceID,
			&i.ChoiceeCount,
			&i.ChoiceeText,
			&i.ChoiceeChoiceID,
			&i.ChoicefCount,
			&i.ChoicefText,
			&i.ChoicefChoiceID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAgendaPreApproved = `-- name: SelectAgendaPreApproved :many
WITH precount AS (
    SELECT
        agenda_master_id AS amid,
        count(*) AS cnt
    FROM
        agenda_acceptence
    GROUP BY
        agenda_master_id
) SELECT --noqa: L022
    agenda_master.agenda_master_id,
    agenda_master.topic_name,
    agenda_master.location_level,
    agenda_master.discussion_details,
    agenda_master.is_approved,
    agenda_master.is_deleted,
    coalesce(precount.cnt, 0) AS acceptancecount
FROM
    agenda_master
LEFT JOIN precount ON agenda_master.agenda_master_id = precount.amid
WHERE
    (
        coalesce(precount.cnt, 0) < 11
        AND agenda_master.is_approved = FALSE
    ) AND (
        agenda_master.location_level = $1
        OR agenda_master.location_level = $2
        OR agenda_master.location_level = $3
    )
ORDER BY coalesce(precount.cnt, 0) DESC
`

type SelectAgendaPreApprovedParams struct {
	LocationLevel   SelectLocations `json:"locationLevel"`
	LocationLevel_2 SelectLocations `json:"locationLevel2"`
	LocationLevel_3 SelectLocations `json:"locationLevel3"`
}

type SelectAgendaPreApprovedRow struct {
	AgendaMasterID    int64           `json:"agendaMasterId"`
	TopicName         string          `json:"topicName"`
	LocationLevel     SelectLocations `json:"locationLevel"`
	DiscussionDetails string          `json:"discussionDetails"`
	IsApproved        bool            `json:"isApproved"`
	IsDeleted         bool            `json:"isDeleted"`
	Acceptancecount   int64           `json:"acceptancecount"`
}

func (q *Queries) SelectAgendaPreApproved(ctx context.Context, arg SelectAgendaPreApprovedParams) ([]*SelectAgendaPreApprovedRow, error) {
	rows, err := q.db.Query(ctx, selectAgendaPreApproved, arg.LocationLevel, arg.LocationLevel_2, arg.LocationLevel_3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAgendaPreApprovedRow{}
	for rows.Next() {
		var i SelectAgendaPreApprovedRow
		if err := rows.Scan(
			&i.AgendaMasterID,
			&i.TopicName,
			&i.LocationLevel,
			&i.DiscussionDetails,
			&i.IsApproved,
			&i.IsDeleted,
			&i.Acceptancecount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectCommentByAgendaID = `-- name: SelectCommentByAgendaID :many
WITH likequery AS (
    SELECT
        agenda_comment_id AS l_id,
        count(*) AS l_count
    FROM
        agenda_comment_reportlikedislike
    WHERE
        comment_response = 'Liked'
    GROUP BY
        agenda_comment_id
), dislikequery AS ( --noqa: L022
    SELECT
        agenda_comment_id AS l_id,
        count(*) AS d_count
    FROM
        agenda_comment_reportlikedislike
    WHERE
        comment_response = 'Disliked'
    GROUP BY
        agenda_comment_id
), replycount AS ( --noqa: L022
    SELECT
        ref_agenda_comment_id AS r_id,
        count(*) AS r_count
    FROM
        agenda_comment
    GROUP BY
        ref_agenda_comment_id
)

SELECT
    agenda_comment.agenda_comment_id, agenda_comment.user_id, agenda_comment.agenda_master_id, agenda_comment.comment_text, agenda_comment.created_at, agenda_comment.updated_at, agenda_comment.ref_agenda_comment_id,
    users.user_id,
    users.display_name,
    users.email_id,
    users.gender,
    users.dob,
    cast(pgp_sym_decrypt(users.first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(users.last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(users.user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(users.ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(users.handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name,
    getagendauservote(agenda_comment.agenda_master_id, agenda_comment.user_id) AS uservote,
    coalesce(likequery.l_count, 0) AS likecount,
    coalesce(dislikequery.d_count, 0) AS dislikecount,
    coalesce(replycount.r_count, 0) AS replycount
FROM
    agenda_comment
INNER JOIN users ON agenda_comment.user_id = users.user_id
LEFT JOIN likequery ON agenda_comment.agenda_comment_id = likequery.l_id
LEFT JOIN dislikequery ON agenda_comment.agenda_comment_id = dislikequery.l_id
LEFT JOIN replycount ON agenda_comment.agenda_comment_id = replycount.r_id
WHERE
    agenda_comment.agenda_master_id = $1
    AND agenda_comment.ref_agenda_comment_id = 0
ORDER BY agenda_comment.agenda_comment_id DESC
`

type SelectCommentByAgendaIDRow struct {
	AgendaCommentID    int64        `json:"agendaCommentId"`
	UserID             int64        `json:"userId"`
	AgendaMasterID     int64        `json:"agendaMasterId"`
	CommentText        string       `json:"commentText"`
	CreatedAt          time.Time    `json:"createdAt"`
	UpdatedAt          time.Time    `json:"updatedAt"`
	RefAgendaCommentID int64        `json:"refAgendaCommentId"`
	UserID_2           int64        `json:"userId2"`
	DisplayName        string       `json:"displayName"`
	EmailID            string       `json:"emailId"`
	Gender             SelectGender `json:"gender"`
	Dob                time.Time    `json:"dob"`
	FirstName          string       `json:"firstName"`
	LastName           string       `json:"lastName"`
	UserAddress        string       `json:"userAddress"`
	PhFixed            string       `json:"phFixed"`
	PhMobile           string       `json:"phMobile"`
	HandleName         string       `json:"handleName"`
	Uservote           string       `json:"uservote"`
	Likecount          int64        `json:"likecount"`
	Dislikecount       int64        `json:"dislikecount"`
	Replycount         int64        `json:"replycount"`
}

func (q *Queries) SelectCommentByAgendaID(ctx context.Context, agendaMasterID int64) ([]*SelectCommentByAgendaIDRow, error) {
	rows, err := q.db.Query(ctx, selectCommentByAgendaID, agendaMasterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectCommentByAgendaIDRow{}
	for rows.Next() {
		var i SelectCommentByAgendaIDRow
		if err := rows.Scan(
			&i.AgendaCommentID,
			&i.UserID,
			&i.AgendaMasterID,
			&i.CommentText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefAgendaCommentID,
			&i.UserID_2,
			&i.DisplayName,
			&i.EmailID,
			&i.Gender,
			&i.Dob,
			&i.FirstName,
			&i.LastName,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.HandleName,
			&i.Uservote,
			&i.Likecount,
			&i.Dislikecount,
			&i.Replycount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectHomeContent = `-- name: SelectHomeContent :many
WITH regular_member AS (
    SELECT
        1 AS rid,
        count(*) AS rcnt
    FROM users
    WHERE
        mobile_verification = TRUE
), associate_member AS ( --noqa: L022
    SELECT
        1 AS aid,
        count(*) AS acnt
    FROM users
), visitor_member AS ( --noqa: L022
    SELECT
        1 AS fid,
        count(*) AS fcnt
    FROM unique_visitor
) SELECT --noqa: L022
    notice_master.notice_text,
    regular_member.rcnt AS regularcount,
    associate_member.acnt AS associatecount,
    visitor_member.fcnt AS membercount
FROM
    notice_master
INNER JOIN regular_member ON notice_master.srno = regular_member.rid
INNER JOIN associate_member ON notice_master.srno = associate_member.aid
INNER JOIN visitor_member ON notice_master.srno = visitor_member.fid
`

type SelectHomeContentRow struct {
	NoticeText     string `json:"noticeText"`
	Regularcount   int64  `json:"regularcount"`
	Associatecount int64  `json:"associatecount"`
	Membercount    int64  `json:"membercount"`
}

func (q *Queries) SelectHomeContent(ctx context.Context) ([]*SelectHomeContentRow, error) {
	rows, err := q.db.Query(ctx, selectHomeContent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectHomeContentRow{}
	for rows.Next() {
		var i SelectHomeContentRow
		if err := rows.Scan(
			&i.NoticeText,
			&i.Regularcount,
			&i.Associatecount,
			&i.Membercount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAgendaApprovedStatus = `-- name: UpdateAgendaApprovedStatus :exec
UPDATE public.agenda_master
SET is_approved = TRUE
WHERE agenda_master_id = $1
`

func (q *Queries) UpdateAgendaApprovedStatus(ctx context.Context, agendaMasterID int64) error {
	_, err := q.db.Exec(ctx, updateAgendaApprovedStatus, agendaMasterID)
	return err
}

const updateAgendaStatus = `-- name: UpdateAgendaStatus :exec
UPDATE agenda_master
SET
    is_approved = TRUE
WHERE
    agenda_master_id IN
    (
        SELECT agenda_master_id
        FROM
            agenda_acceptence
        GROUP BY agenda_master_id
        HAVING count(*) > 10
    )
`

func (q *Queries) UpdateAgendaStatus(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateAgendaStatus)
	return err
}

const updateDeletedByAgendaId = `-- name: UpdateDeletedByAgendaId :exec
UPDATE agenda_master
SET
    is_deleted = TRUE
WHERE
    agenda_master_id = $1
`

func (q *Queries) UpdateDeletedByAgendaId(ctx context.Context, agendaMasterID int64) error {
	_, err := q.db.Exec(ctx, updateDeletedByAgendaId, agendaMasterID)
	return err
}

const voteAgendaCountByAgendaUserId = `-- name: VoteAgendaCountByAgendaUserId :one
SELECT count(*) AS cnt
FROM
    agenda_vote
WHERE
    agenda_master_id = $1
    AND user_id = $2
`

type VoteAgendaCountByAgendaUserIdParams struct {
	AgendaMasterID int64 `json:"agendaMasterId"`
	UserID         int64 `json:"userId"`
}

func (q *Queries) VoteAgendaCountByAgendaUserId(ctx context.Context, arg VoteAgendaCountByAgendaUserIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, voteAgendaCountByAgendaUserId, arg.AgendaMasterID, arg.UserID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}
