// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: petition.sql

package gen

import (
	"context"
	"time"

	database "ZenitusJPP/database"
)

const checkPetitionMailCount = `-- name: CheckPetitionMailCount :one
SELECT count(*)
FROM petition_mail
WHERE
    petition_master_id = $1
    AND email_id = $2
`

type CheckPetitionMailCountParams struct {
	PetitionMasterID int64  `json:"petitionMasterId"`
	EmailID          string `json:"emailId"`
}

func (q *Queries) CheckPetitionMailCount(ctx context.Context, arg CheckPetitionMailCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkPetitionMailCount, arg.PetitionMasterID, arg.EmailID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertPetitionInfo = `-- name: InsertPetitionInfo :one
INSERT INTO petition_master (
    user_id,
    title,
    locationlevel,
    user_target,
    petition_content,
    submission_address,
    deadline,
    recruitmentcomments
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING petition_master_id
`

type InsertPetitionInfoParams struct {
	UserID              int64          `json:"userId"`
	Title               string         `json:"title"`
	Locationlevel       SelectLocation `json:"locationlevel"`
	UserTarget          string         `json:"userTarget"`
	PetitionContent     string         `json:"petitionContent"`
	SubmissionAddress   string         `json:"submissionAddress"`
	Deadline            time.Time      `json:"deadline"`
	Recruitmentcomments string         `json:"recruitmentcomments"`
}

func (q *Queries) InsertPetitionInfo(ctx context.Context, arg InsertPetitionInfoParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertPetitionInfo,
		arg.UserID,
		arg.Title,
		arg.Locationlevel,
		arg.UserTarget,
		arg.PetitionContent,
		arg.SubmissionAddress,
		arg.Deadline,
		arg.Recruitmentcomments,
	)
	var petition_master_id int64
	err := row.Scan(&petition_master_id)
	return petition_master_id, err
}

const insertPetitionMailInfo = `-- name: InsertPetitionMailInfo :one
INSERT INTO petition_mail
(
    petition_master_id,
    user_id,
    email_id
) VALUES (
    $1,
    $2,
    $3
) RETURNING petition_mail_id
`

type InsertPetitionMailInfoParams struct {
	PetitionMasterID int64  `json:"petitionMasterId"`
	UserID           int64  `json:"userId"`
	EmailID          string `json:"emailId"`
}

func (q *Queries) InsertPetitionMailInfo(ctx context.Context, arg InsertPetitionMailInfoParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertPetitionMailInfo, arg.PetitionMasterID, arg.UserID, arg.EmailID)
	var petition_mail_id int64
	err := row.Scan(&petition_mail_id)
	return petition_mail_id, err
}

const insertPetitionSign = `-- name: InsertPetitionSign :one
INSERT INTO petition_acceptence (
    user_id,
    petition_master_id
) VALUES (
    $1,
    $2
) RETURNING petition_acceptence_id
`

type InsertPetitionSignParams struct {
	UserID           int64 `json:"userId"`
	PetitionMasterID int64 `json:"petitionMasterId"`
}

func (q *Queries) InsertPetitionSign(ctx context.Context, arg InsertPetitionSignParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertPetitionSign, arg.UserID, arg.PetitionMasterID)
	var petition_acceptence_id int64
	err := row.Scan(&petition_acceptence_id)
	return petition_acceptence_id, err
}

const selectAllUseracceptenceByPetitionID = `-- name: SelectAllUseracceptenceByPetitionID :many
SELECT
    petition_acceptence.petition_acceptence_id,
    petition_acceptence.petition_master_id,
    users.user_id,
    users.display_name,
    users.email_id,
    users.gender,
    users.dob,
    users.created_on,
    cast(pgp_sym_decrypt(users.first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(users.last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(users.user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(users.ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(users.handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name
FROM
    petition_acceptence
INNER JOIN users ON petition_acceptence.user_id = users.user_id
WHERE
    petition_acceptence.petition_master_id = $1
`

type SelectAllUseracceptenceByPetitionIDRow struct {
	PetitionAcceptenceID int64        `json:"petitionAcceptenceId"`
	PetitionMasterID     int64        `json:"petitionMasterId"`
	UserID               int64        `json:"userId"`
	DisplayName          string       `json:"displayName"`
	EmailID              string       `json:"emailId"`
	Gender               SelectGender `json:"gender"`
	Dob                  time.Time    `json:"dob"`
	CreatedOn            time.Time    `json:"createdOn"`
	FirstName            string       `json:"firstName"`
	LastName             string       `json:"lastName"`
	UserAddress          string       `json:"userAddress"`
	PhFixed              string       `json:"phFixed"`
	PhMobile             string       `json:"phMobile"`
	HandleName           string       `json:"handleName"`
}

func (q *Queries) SelectAllUseracceptenceByPetitionID(ctx context.Context, petitionMasterID int64) ([]*SelectAllUseracceptenceByPetitionIDRow, error) {
	rows, err := q.db.Query(ctx, selectAllUseracceptenceByPetitionID, petitionMasterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectAllUseracceptenceByPetitionIDRow{}
	for rows.Next() {
		var i SelectAllUseracceptenceByPetitionIDRow
		if err := rows.Scan(
			&i.PetitionAcceptenceID,
			&i.PetitionMasterID,
			&i.UserID,
			&i.DisplayName,
			&i.EmailID,
			&i.Gender,
			&i.Dob,
			&i.CreatedOn,
			&i.FirstName,
			&i.LastName,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.HandleName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectCountpetitionacceptancebyUserIDPetitionAcceptanceID = `-- name: SelectCountpetitionacceptancebyUserIDPetitionAcceptanceID :one
SELECT count(*) AS cnt
FROM petition_acceptence
WHERE
    petition_master_id = $1
    AND user_id = $2
`

type SelectCountpetitionacceptancebyUserIDPetitionAcceptanceIDParams struct {
	PetitionMasterID int64 `json:"petitionMasterId"`
	UserID           int64 `json:"userId"`
}

func (q *Queries) SelectCountpetitionacceptancebyUserIDPetitionAcceptanceID(ctx context.Context, arg SelectCountpetitionacceptancebyUserIDPetitionAcceptanceIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, selectCountpetitionacceptancebyUserIDPetitionAcceptanceID, arg.PetitionMasterID, arg.UserID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const selectPetitionInfo = `-- name: SelectPetitionInfo :many
WITH petitionacceptancecount AS (
    SELECT
        petition_master_id AS pi_id,
        count(*) AS cnt
    FROM
        petition_acceptence
    GROUP BY
        petition_master_id
) SELECT --noqa: L022
    petition_master.petition_master_id,
    petition_master.user_id,
    petition_master.title,
    petition_master.locationlevel,
    petition_master.user_target,
    petition_master.submission_address,
    petition_master.deadline,
    petition_master.recruitmentcomments,
    petition_master.is_deleted,
    petition_master.created_at,
    petition_master.updated_at,
    users.user_id,
    users.display_name,
    users.email_id,
    users.gender,
    users.dob,
    users.created_on,
    petitionacceptancecount.pi_id,
    cast(pgp_sym_decrypt(users.first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(users.last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(users.user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(users.ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(users.handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name,
    regexp_replace(petition_master.petition_content, E'[\\n\\r]+', '<br/>', 'g' ) AS petition_content,
    coalesce(petitionacceptancecount.cnt, 0) AS pcount
FROM
    petition_master
INNER JOIN users ON petition_master.user_id = users.user_id
LEFT JOIN petitionacceptancecount ON petition_master.petition_master_id = petitionacceptancecount.pi_id
WHERE
    petition_master.is_deleted = FALSE
`

type SelectPetitionInfoRow struct {
	PetitionMasterID    int64              `json:"petitionMasterId"`
	UserID              int64              `json:"userId"`
	Title               string             `json:"title"`
	Locationlevel       SelectLocation     `json:"locationlevel"`
	UserTarget          string             `json:"userTarget"`
	SubmissionAddress   string             `json:"submissionAddress"`
	Deadline            time.Time          `json:"deadline"`
	Recruitmentcomments string             `json:"recruitmentcomments"`
	IsDeleted           bool               `json:"isDeleted"`
	CreatedAt           time.Time          `json:"createdAt"`
	UpdatedAt           time.Time          `json:"updatedAt"`
	UserID_2            int64              `json:"userId2"`
	DisplayName         string             `json:"displayName"`
	EmailID             string             `json:"emailId"`
	Gender              SelectGender       `json:"gender"`
	Dob                 time.Time          `json:"dob"`
	CreatedOn           time.Time          `json:"createdOn"`
	PiID                database.NullInt64 `json:"piId"`
	FirstName           string             `json:"firstName"`
	LastName            string             `json:"lastName"`
	UserAddress         string             `json:"userAddress"`
	PhFixed             string             `json:"phFixed"`
	PhMobile            string             `json:"phMobile"`
	HandleName          string             `json:"handleName"`
	PetitionContent     string             `json:"petitionContent"`
	Pcount              int64              `json:"pcount"`
}

func (q *Queries) SelectPetitionInfo(ctx context.Context) ([]*SelectPetitionInfoRow, error) {
	rows, err := q.db.Query(ctx, selectPetitionInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectPetitionInfoRow{}
	for rows.Next() {
		var i SelectPetitionInfoRow
		if err := rows.Scan(
			&i.PetitionMasterID,
			&i.UserID,
			&i.Title,
			&i.Locationlevel,
			&i.UserTarget,
			&i.SubmissionAddress,
			&i.Deadline,
			&i.Recruitmentcomments,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID_2,
			&i.DisplayName,
			&i.EmailID,
			&i.Gender,
			&i.Dob,
			&i.CreatedOn,
			&i.PiID,
			&i.FirstName,
			&i.LastName,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.HandleName,
			&i.PetitionContent,
			&i.Pcount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPetitionInfoByPetitionId = `-- name: SelectPetitionInfoByPetitionId :many
WITH petitionacceptancecount AS (
    SELECT
        petition_master_id AS pi_id,
        count(*) AS cnt
    FROM
        petition_acceptence
    GROUP BY
        petition_master_id
) SELECT --noqa: L022
    petition_master.petition_master_id,
    petition_master.user_id,
    petition_master.title,
    petition_master.locationlevel,
    petition_master.user_target,
    petition_master.submission_address,
    petition_master.deadline,
    petition_master.is_deleted,
    petition_master.created_at,
    petition_master.updated_at,
    users.user_id,
    users.display_name,
    users.email_id,
    users.gender,
    users.dob,
    users.created_on,
    petitionacceptancecount.pi_id,
    cast(pgp_sym_decrypt(users.first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(users.last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(users.user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(users.ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(users.handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name,
    regexp_replace(petition_master.petition_content, E'[\\n\\r]+', '<br/>', 'g' ) AS petition_content,
    regexp_replace(petition_master.recruitmentcomments, E'[\\n\\r]+', '<br/>', 'g' ) AS recruitmentcomments,
    coalesce(petitionacceptancecount.cnt, 0) AS pcount
FROM petition_master
INNER JOIN users ON petition_master.user_id = users.user_id
LEFT JOIN petitionacceptancecount ON petition_master.petition_master_id = petitionacceptancecount.pi_id
WHERE
    petition_master.petition_master_id = $1
`

type SelectPetitionInfoByPetitionIdRow struct {
	PetitionMasterID    int64              `json:"petitionMasterId"`
	UserID              int64              `json:"userId"`
	Title               string             `json:"title"`
	Locationlevel       SelectLocation     `json:"locationlevel"`
	UserTarget          string             `json:"userTarget"`
	SubmissionAddress   string             `json:"submissionAddress"`
	Deadline            time.Time          `json:"deadline"`
	IsDeleted           bool               `json:"isDeleted"`
	CreatedAt           time.Time          `json:"createdAt"`
	UpdatedAt           time.Time          `json:"updatedAt"`
	UserID_2            int64              `json:"userId2"`
	DisplayName         string             `json:"displayName"`
	EmailID             string             `json:"emailId"`
	Gender              SelectGender       `json:"gender"`
	Dob                 time.Time          `json:"dob"`
	CreatedOn           time.Time          `json:"createdOn"`
	PiID                database.NullInt64 `json:"piId"`
	FirstName           string             `json:"firstName"`
	LastName            string             `json:"lastName"`
	UserAddress         string             `json:"userAddress"`
	PhFixed             string             `json:"phFixed"`
	PhMobile            string             `json:"phMobile"`
	HandleName          string             `json:"handleName"`
	PetitionContent     string             `json:"petitionContent"`
	Recruitmentcomments string             `json:"recruitmentcomments"`
	Pcount              int64              `json:"pcount"`
}

func (q *Queries) SelectPetitionInfoByPetitionId(ctx context.Context, petitionMasterID int64) ([]*SelectPetitionInfoByPetitionIdRow, error) {
	rows, err := q.db.Query(ctx, selectPetitionInfoByPetitionId, petitionMasterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectPetitionInfoByPetitionIdRow{}
	for rows.Next() {
		var i SelectPetitionInfoByPetitionIdRow
		if err := rows.Scan(
			&i.PetitionMasterID,
			&i.UserID,
			&i.Title,
			&i.Locationlevel,
			&i.UserTarget,
			&i.SubmissionAddress,
			&i.Deadline,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID_2,
			&i.DisplayName,
			&i.EmailID,
			&i.Gender,
			&i.Dob,
			&i.CreatedOn,
			&i.PiID,
			&i.FirstName,
			&i.LastName,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.HandleName,
			&i.PetitionContent,
			&i.Recruitmentcomments,
			&i.Pcount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPetitionList = `-- name: SelectPetitionList :many
WITH petitionacceptancecount AS (
    SELECT
        petition_master_id AS pi_id,
        count(*) AS cnt
    FROM
        petition_acceptence
    GROUP BY
        petition_master_id
) SELECT --noqa: L022
    petition_master.petition_master_id,
    users.display_name,
    petition_master.user_id,
    petition_master.title,
    petition_master.locationlevel,
    petition_master.user_target,
    petition_master.submission_address,
    petition_master.deadline,
    petition_master.created_at,
    petitionacceptancecount.pi_id,
    cast(pgp_sym_decrypt(users.first_name, 'SLMSZ1929S') AS VARCHAR) AS first_name,
    cast(pgp_sym_decrypt(users.last_name, 'SLMSZ1929S') AS VARCHAR) AS last_name,
    cast(pgp_sym_decrypt(users.user_address, 'SLMSZ1929S') AS VARCHAR) AS user_address,
    cast(pgp_sym_decrypt(users.ph_fixed, 'SLMSZ1929S') AS VARCHAR) AS ph_fixed,
    cast(pgp_sym_decrypt(users.ph_mobile, 'SLMSZ1929S') AS VARCHAR) AS ph_mobile,
    cast(pgp_sym_decrypt(users.handle_name, 'SLMSZ1929S') AS VARCHAR) AS handle_name,
    regexp_replace(petition_master.petition_content, E'[\\n\\r]+', '<br/>', 'g' ) AS petition_content,
    regexp_replace(petition_master.recruitmentcomments, E'[\\n\\r]+', '<br/>', 'g' ) AS recruitmentcomments,
    coalesce(petitionacceptancecount.cnt, 0) AS pcount
FROM petition_master
INNER JOIN users ON petition_master.user_id = users.user_id
LEFT JOIN petitionacceptancecount ON petition_master.petition_master_id = petitionacceptancecount.pi_id
WHERE
    (
        petition_master.locationlevel = $1
        OR petition_master.locationlevel = $2
        OR petition_master.locationlevel = $3
    )
    AND petition_master.is_deleted = FALSE
ORDER BY petition_master.petition_master_id DESC
`

type SelectPetitionListParams struct {
	Locationlevel   SelectLocation `json:"locationlevel"`
	Locationlevel_2 SelectLocation `json:"locationlevel2"`
	Locationlevel_3 SelectLocation `json:"locationlevel3"`
}

type SelectPetitionListRow struct {
	PetitionMasterID    int64              `json:"petitionMasterId"`
	DisplayName         string             `json:"displayName"`
	UserID              int64              `json:"userId"`
	Title               string             `json:"title"`
	Locationlevel       SelectLocation     `json:"locationlevel"`
	UserTarget          string             `json:"userTarget"`
	SubmissionAddress   string             `json:"submissionAddress"`
	Deadline            time.Time          `json:"deadline"`
	CreatedAt           time.Time          `json:"createdAt"`
	PiID                database.NullInt64 `json:"piId"`
	FirstName           string             `json:"firstName"`
	LastName            string             `json:"lastName"`
	UserAddress         string             `json:"userAddress"`
	PhFixed             string             `json:"phFixed"`
	PhMobile            string             `json:"phMobile"`
	HandleName          string             `json:"handleName"`
	PetitionContent     string             `json:"petitionContent"`
	Recruitmentcomments string             `json:"recruitmentcomments"`
	Pcount              int64              `json:"pcount"`
}

func (q *Queries) SelectPetitionList(ctx context.Context, arg SelectPetitionListParams) ([]*SelectPetitionListRow, error) {
	rows, err := q.db.Query(ctx, selectPetitionList, arg.Locationlevel, arg.Locationlevel_2, arg.Locationlevel_3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SelectPetitionListRow{}
	for rows.Next() {
		var i SelectPetitionListRow
		if err := rows.Scan(
			&i.PetitionMasterID,
			&i.DisplayName,
			&i.UserID,
			&i.Title,
			&i.Locationlevel,
			&i.UserTarget,
			&i.SubmissionAddress,
			&i.Deadline,
			&i.CreatedAt,
			&i.PiID,
			&i.FirstName,
			&i.LastName,
			&i.UserAddress,
			&i.PhFixed,
			&i.PhMobile,
			&i.HandleName,
			&i.PetitionContent,
			&i.Recruitmentcomments,
			&i.Pcount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeletedByPetitionId = `-- name: UpdateDeletedByPetitionId :exec
UPDATE petition_master
SET
    is_deleted = TRUE
WHERE
    petition_master_id = $1
`

func (q *Queries) UpdateDeletedByPetitionId(ctx context.Context, petitionMasterID int64) error {
	_, err := q.db.Exec(ctx, updateDeletedByPetitionId, petitionMasterID)
	return err
}

const updatePetitionInfoByID = `-- name: UpdatePetitionInfoByID :exec
UPDATE petition_master
SET
    title = $1,
    locationlevel = $2,
    user_target = $3,
    petition_content = $4,
    submission_address = $5,
    deadline = $6,
    recruitmentcomments = $7
WHERE
    petition_master_id = $8
`

type UpdatePetitionInfoByIDParams struct {
	Title               string         `json:"title"`
	Locationlevel       SelectLocation `json:"locationlevel"`
	UserTarget          string         `json:"userTarget"`
	PetitionContent     string         `json:"petitionContent"`
	SubmissionAddress   string         `json:"submissionAddress"`
	Deadline            time.Time      `json:"deadline"`
	Recruitmentcomments string         `json:"recruitmentcomments"`
	PetitionMasterID    int64          `json:"petitionMasterId"`
}

func (q *Queries) UpdatePetitionInfoByID(ctx context.Context, arg UpdatePetitionInfoByIDParams) error {
	_, err := q.db.Exec(ctx, updatePetitionInfoByID,
		arg.Title,
		arg.Locationlevel,
		arg.UserTarget,
		arg.PetitionContent,
		arg.SubmissionAddress,
		arg.Deadline,
		arg.Recruitmentcomments,
		arg.PetitionMasterID,
	)
	return err
}
